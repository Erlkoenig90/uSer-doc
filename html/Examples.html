<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>µSer: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">µSer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Examples.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Ex01">Serializing an integer into an array</a></li>
<li class="level1"><a href="#Ex02">Deserializing an integer from an array</a></li>
<li class="level1"><a href="#Ex03">Serializing an array of integers into an array</a></li>
<li class="level1"><a href="#Ex04">Serializing a tuple of integers into an array</a></li>
<li class="level1"><a href="#Ex05">Serializing a vector of integers into an array</a></li>
<li class="level1"><a href="#Ex06">Pre-Processing raw data with swapped bytes</a></li>
<li class="level1"><a href="#Ex07">Specifying attributes via function arguments</a></li>
<li class="level1"><a href="#Ex08">Serializing an integer into a std::vector</a></li>
<li class="level1"><a href="#Ex09">Serializing an integer into a std::vector with FixedSize</a></li>
<li class="level1"><a href="#Ex10">Deserializing an integer from a dynamically-sized std::vector with DynSize</a></li>
<li class="level1"><a href="#Ex11">Serializing an integer into a std::vector with InfSize</a></li>
<li class="level1"><a href="#Ex12">Using return codes to process errors</a></li>
<li class="level1"><a href="#Ex13">Defining a simple struct for serialization</a></li>
<li class="level1"><a href="#Ex14">Annotating a struct with attributes</a></li>
<li class="level1"><a href="#Ex15">Annotating a struct member with attributes</a></li>
<li class="level1"><a href="#Ex16">Defining and annotating a struct member in one step</a></li>
<li class="level1"><a href="#Ex17">Defining and annotating all struct members in one step</a></li>
<li class="level1"><a href="#Ex18">Annotating a struct without modifying its definition</a></li>
<li class="level1"><a href="#Ex19">Annotating a struct without modifying its definition in a compact fashion</a></li>
<li class="level1"><a href="#Ex20">Serializing an integer that is not a multiple of a byte in different byte orders</a></li>
<li class="level1"><a href="#Ex21">Serializing a signed integer with different sign formats</a></li>
<li class="level1"><a href="#Ex22">Setting integer width to convert RGB565 color values</a></li>
<li class="level1"><a href="#Ex23">Using padding bits to skip dummy data in the raw stream</a></li>
<li class="level1"><a href="#Ex24">Convert a file&#39;s byte order by using input/output iterators</a></li>
<li class="level1"><a href="#Ex25">Convert a file&#39;s byte order by using custom input/output iterators</a></li>
<li class="level1"><a href="#Ex26">Deserializing a vector of integers from an array.</a></li>
<li class="level1"><a href="#Ex27">Defining dynamic data structures with Dyn::Size</a></li>
<li class="level1"><a href="#Ex28">Defining optional data structures with Dyn::Optional</a></li>
<li class="level1"><a href="#Ex29">Defining hook funktions to be called before/after (de)serialization</a></li>
<li class="level1"><a href="#ExC">Using µSer in C projects</a><ul><li class="level2"><a href="#ExC_Hdr">Common header file for data structures</a></li>
<li class="level2"><a href="#ExC_Ser">Implementation of the C++ serialization functions</a></li>
<li class="level2"><a href="#ExC_main">Calling serialization functions from C code</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>µSer ships with a set of examples in the "examples" subdirectory. Run "make" in that directory to compile them all. The "examples/C" directory contains an <a class="el" href="Examples.html#ExC">example</a> for using µSer with a C project consisting of multiple files.</p>
<h1><a class="anchor" id="Ex01"></a>
Serializing an integer into an array</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex02"></a>
Deserializing an integer from an array</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ios&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array with binary data to be deserialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint8_t raw [4] = { 0x54, 0x45, 0x53, 0x54 };</div><div class="line">    <span class="comment">// Define a variable that receives the deserialized data.</span></div><div class="line">    std::uint32_t x;</div><div class="line">    <span class="comment">// Perform the actual deserialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the result to standard output.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex03"></a>
Serializing an array of integers into an array</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::array&lt;std::uint16_t, 2&gt; x {{ 0x4554, 0x5453 }};</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex04"></a>
Serializing a tuple of integers into an array</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::tuple&lt;std::uint16_t, std::uint8_t, std::uint8_t&gt; x { 0x4554, 0x53, 0x54 };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex05"></a>
Serializing a vector of integers into an array</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::uint16_t&gt; x { 0x4554, 0x5453 };</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual serialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">        <span class="comment">// Write the binary data to standard output.</span></div><div class="line">        std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex06"></a>
Pre-Processing raw data with swapped bytes</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    std::tuple&lt;std::uint16_t, std::uint8_t, std::uint8_t&gt; x { 0x4554, 0x53, 0x54 };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Simulate a communication channel which combines the 8-Bit-Integers into 16-Bit-Integers</span></div><div class="line">    <span class="comment">// in a big endian way:</span></div><div class="line">    std::uint16_t raw2 [2];</div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; <span class="keyword">sizeof</span>(raw)/2 <span class="comment">/* uint8_t always has size 1 */</span>; ++i) {</div><div class="line">        raw2[i] = <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span> ((uint16_t { raw[i*2] } &lt;&lt; 8) | raw [i*2+1]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Turn the swapped 16-Bit-Words back into a sequence of words where the least significant bit comes first</span></div><div class="line">    std::uint16_t raw3 [2];</div><div class="line">    uSer::deserialize&lt;uSer::ByteOrder::BE&gt; (raw2, raw3);</div><div class="line"></div><div class="line">    <span class="comment">// Actually deserialize the data</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw3, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the data to standard output. We need to convert the uint8_t elements into integers,</span></div><div class="line">    <span class="comment">// because else they will be interpreted as individual characters.</span></div><div class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; std::get&lt;0&gt; (x) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { std::get&lt;1&gt; (x) } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { std::get&lt;2&gt; (x) } &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex07"></a>
Specifying attributes via function arguments</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint_least32_t x = 0x54534554;</div><div class="line">    <span class="comment">// Perform the actual serialization in Big Endian order.</span></div><div class="line">    uSer::serialize&lt;uSer::ByteOrder::BE, uSer::Width&lt;32&gt;&gt; (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex08"></a>
Serializing an integer into a std::vector</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a vector to receive the raw binary data.</span></div><div class="line">    std::vector&lt;std::uint8_t&gt; raw (4);</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual serialization. Implicitly uses raw.size() to obtain the raw buffer size.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">        <span class="comment">// Write the binary data to standard output.</span></div><div class="line">        std::cout.write (reinterpret_cast&lt;char*&gt; (raw.data ()), 4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex09"></a>
Serializing an integer into a std::vector with FixedSize</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a vector to receive the raw binary data.</span></div><div class="line">    std::vector&lt;std::uint8_t&gt; raw (4);</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x, uSer::fixedSize&lt;4&gt;);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw.data ()), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex10"></a>
Deserializing an integer from a dynamically-sized std::vector with DynSize</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a vector to with the raw binary data.</span></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::uint8_t&gt; raw { 0xBE, 0xBA, 0xFE, 0xC0, 0xEF, 0xBE, 0xAD, 0xDE };</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Define a variable to receive the deserialized data</span></div><div class="line">        std::uint32_t x;</div><div class="line">        <span class="comment">// Perform the actual deserialization while using only the first half of the buffer.</span></div><div class="line">        uSer::deserialize&lt;uSer::RawInfo&lt;uint16_t, 8&gt;&gt; (raw, x, raw.size () / 2);</div><div class="line"><span class="comment">//      uSer::deserialize (raw, x, uSer::DynSize { raw.size () / 2 });  // Same functionality made explicit</span></div><div class="line"></div><div class="line">        <span class="comment">// Write the integer to standard output.</span></div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex11"></a>
Serializing an integer into a std::vector with InfSize</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a vector to receive the raw binary data.</span></div><div class="line">    std::vector&lt;std::uint8_t&gt; raw;</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line"></div><div class="line">    <span class="comment">// Perform the actual serialization; automatically append elements</span></div><div class="line">    <span class="comment">// to the raw vector without an explicit size limit.</span></div><div class="line">    uSer::serialize&lt;uSer::RawInfo&lt;std::uint8_t&gt;&gt; (std::back_inserter (raw), x, uSer::infSize);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;const char*&gt; (raw.data ()), static_cast&lt;std::streamsize&gt; (raw.size ())) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex12"></a>
Using return codes to process errors</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::uint16_t&gt; x { 0x4554, 0x5453 };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> ec = <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Check for success</span></div><div class="line">    <span class="keywordflow">if</span> (ec == <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a>) {</div><div class="line">        <span class="comment">// Write the binary data to standard output.</span></div><div class="line">        std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// Print error message</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; <a class="code" href="uSer_8hh.html#ae554bbbb88b9dd386e21dda79645dca1">uSer_getErrorMessage</a>(ec) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex13"></a>
Defining a simple struct for serialization</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line"><span class="comment">//  USER_STRUCT (A, uSer::AttrNone)</span></div><div class="line"></div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    std::uint32_t d;</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex14"></a>
Annotating a struct with attributes</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="structuSer_1_1ByteOrder_1_1BE.html">uSer::ByteOrder::BE</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    std::uint32_t d;</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex15"></a>
Annotating a struct member with attributes</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="structuSer_1_1ByteOrder_1_1BE.html">uSer::ByteOrder::BE</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    std::uint32_t d;</div><div class="line"></div><div class="line">    <span class="comment">// Annotate a member</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(d, <a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex16"></a>
Defining and annotating a struct member in one step</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line"></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    <a class="code" href="uSer_8hh.html#aa698c0d67c4648448cff3db1230633fb">USER_MEM</a>(std::uint32_t, d, <a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line"></div><div class="line">    <span class="comment">// Annotate a member</span></div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex17"></a>
Defining and annotating all struct members in one step</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define and annotate multiple members</span></div><div class="line"></div><div class="line">    <a class="code" href="uSer_8hh.html#a4b9dbf8cddfb3649be7fe5dabe720738">USER_DEF_MEM</a>(</div><div class="line">            (std::uint16_t,a,<a class="code" href="namespaceuSer.html">uSer</a>::AttrNone),</div><div class="line">            (std::uint16_t,b),</div><div class="line">            (std::uint8_t,c),</div><div class="line">            (std::uint32_t,d,<a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line">    )</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex18"></a>
Annotating a struct without modifying its definition</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>N {</div><div class="line">    <span class="comment">// Normal definition of a struct</span></div><div class="line">    <span class="keyword">struct </span>A {</div><div class="line">        <span class="comment">// Define arbitrary members</span></div><div class="line">        std::uint16_t a, b;</div><div class="line">        std::uint8_t c;</div><div class="line">        std::uint32_t d;</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// These macro calls need to be in the global scope.</span></div><div class="line"></div><div class="line"><span class="comment">// Optional: Define attributes for the whole struct.</span></div><div class="line"><a class="code" href="uSer_8hh.html#a1038046f66eb6f26c458ed93f44e8883">USER_EXT_ANNOT</a>(N::A, <a class="code" href="structuSer_1_1ByteOrder_1_1LE.html">uSer::ByteOrder::LE</a>)</div><div class="line"></div><div class="line"><span class="comment">// Optional: Annotate a struct member</span></div><div class="line"><a class="code" href="uSer_8hh.html#a95a301f4f3647a9da1c54c64d88dab14">USER_EXT_MEM_ANNOT</a>(N::A, d, <a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line"></div><div class="line"><span class="comment">// List all struct members</span></div><div class="line"><a class="code" href="uSer_8hh.html#a568cacede8a3c880e8e9356243b76dd8">USER_EXT_ENUM_MEM</a>(N::A, a, b, c, d)</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    N::A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex19"></a>
Annotating a struct without modifying its definition in a compact fashion</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>N {</div><div class="line">    <span class="comment">// Normal definition of a struct</span></div><div class="line">    <span class="keyword">struct </span>A {</div><div class="line">        <span class="comment">// Define arbitrary members</span></div><div class="line">        std::uint16_t a, b;</div><div class="line">        std::uint8_t c;</div><div class="line">        std::uint32_t d;</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// These macro calls need to be in the global scope.</span></div><div class="line"></div><div class="line"><span class="comment">// Optional: Define attributes for the whole struct.</span></div><div class="line"><a class="code" href="uSer_8hh.html#a1038046f66eb6f26c458ed93f44e8883">USER_EXT_ANNOT</a>(N::A, <a class="code" href="structuSer_1_1ByteOrder_1_1LE.html">uSer::ByteOrder::LE</a>)</div><div class="line"></div><div class="line"><span class="comment">// List all struct members</span></div><div class="line"><a class="code" href="uSer_8hh.html#a74c5c1444f1efe3192ece5bd7fb72556">USER_EXT_DEF_MEM</a>(N::A,</div><div class="line">        (a,<a class="code" href="namespaceuSer.html">uSer</a>::AttrNone),</div><div class="line">        (b),</div><div class="line">        (c),</div><div class="line">        (d,<a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE))</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    N::A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex20"></a>
Serializing an integer that is not a multiple of a byte in different byte orders</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [2];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    std::uint16_t x = 0x765;</div><div class="line">    <span class="comment">// Serialize as little endian</span></div><div class="line">    uSer::serialize&lt;uSer::ByteOrder::LE, uSer::Width&lt;11&gt;&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Serialize as big endian</span></div><div class="line">    uSer::serialize&lt;uSer::ByteOrder::BE, uSer::Width&lt;11&gt;&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex21"></a>
Serializing a signed integer with different sign formats</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [2];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::int16_t x = -291;</div><div class="line"></div><div class="line">    <span class="comment">// Serialize as 2&#39;s complement</span></div><div class="line">    uSer::serialize&lt;uSer::SignFormat::TwosComplement&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Serialize as 1&#39;s complement</span></div><div class="line">    uSer::serialize&lt;uSer::SignFormat::OnesComplement&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Serialize as signed-magnitude</span></div><div class="line">    uSer::serialize&lt;uSer::SignFormat::SignedMagnitude&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex22"></a>
Setting integer width to convert RGB565 color values</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct for storing colors in RGB565 format.</span></div><div class="line"><span class="keyword">struct </span>Color {</div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (Color, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define color components.</span></div><div class="line">    std::uint8_t r, g, b;</div><div class="line"></div><div class="line">    <span class="comment">// Explicitly set the sizes of the integers</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(r, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;5&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(g, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;6&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(b, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;5&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (r, g, b)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Store the binary data in a 16bit-Integer</span></div><div class="line">    std::uint16_t raw [1];</div><div class="line">    <span class="comment">// Define a color to be serialized.</span></div><div class="line">    Color c1 { 24, 55, 12 };</div><div class="line">    <span class="comment">// Convert RGB565-Color into 16bit-Value</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, c1);</div><div class="line"></div><div class="line">    <span class="comment">// Output the raw value</span></div><div class="line">    std::cout &lt;&lt; std::hex &lt;&lt; std::setw(4) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; raw[0] &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex23"></a>
Using padding bits to skip dummy data in the raw stream</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct for storing colors in RGB565 format.</span></div><div class="line"><span class="keyword">struct </span>Color {</div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (Color, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define color components.</span></div><div class="line">    std::uint8_t r, b;</div><div class="line"></div><div class="line">    <span class="comment">// Explicitly set the sizes of the integers</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(r, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;5&gt;, <a class="code" href="namespaceuSer.html">uSer</a>::Padding::Fixed&lt;6&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(b, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;5&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (r, b)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Store the binary data in a 16bit-Integer</span></div><div class="line">    std::uint16_t raw [1];</div><div class="line">    <span class="comment">// Define a color to be serialized.</span></div><div class="line">    Color c1 { 24, 12 };</div><div class="line">    <span class="comment">// Convert RGB565-Color into 16bit-Value</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, c1);</div><div class="line"></div><div class="line">    <span class="comment">// Output the raw value</span></div><div class="line">    std::cout &lt;&lt; std::hex &lt;&lt; std::setw(4) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; raw[0] &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex24"></a>
Convert a file's byte order by using input/output iterators</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ios&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Open input file</span></div><div class="line">        std::ifstream input (<span class="stringliteral">&quot;rawdata.be&quot;</span>, std::ios::binary);</div><div class="line">        <span class="keywordflow">if</span> (!input)</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;File could not be opened&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Determine file size</span></div><div class="line">        input.seekg (0, std::ios::end);</div><div class="line">        std::size_t fSize = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span> (input.tellg ());</div><div class="line">        input.seekg (0, std::ios::beg);</div><div class="line"></div><div class="line">        std::uint32_t x;</div><div class="line">        <span class="comment">// Read a 32-Bit-Integer as big endian</span></div><div class="line">        uSer::deserialize&lt;uSer::ByteOrder::BE&gt; (std::istream_iterator&lt;std::uint8_t&gt; (input), x, fSize);</div><div class="line"></div><div class="line">        <span class="comment">// Open output file</span></div><div class="line">        std::ofstream output (<span class="stringliteral">&quot;rawdata.le&quot;</span>, std::ios::binary);</div><div class="line">        output.exceptions (std::ofstream::failbit);</div><div class="line"></div><div class="line">        <span class="comment">// Write the integer as little endian</span></div><div class="line">        uSer::serialize&lt;uSer::RawInfo&lt;std::uint8_t&gt;, <a class="code" href="structuSer_1_1ByteOrder_1_1LE.html">uSer::ByteOrder::LE</a>&gt; (std::ostream_iterator&lt;std::uint8_t&gt; (output), x, uSer::infSize);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">        <span class="comment">// Handle errors</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex25"></a>
Convert a file's byte order by using custom input/output iterators</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ios&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>InIter {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        InIter (std::istream&amp; os) : m_stream (&amp;os) {}</div><div class="line">        InIter (InIter&amp;&amp; src) = <span class="keywordflow">default</span>;</div><div class="line">        InIter&amp; operator = (InIter&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Type Definitions for std::iterator_traits</span></div><div class="line">        <span class="keyword">using</span> value_type = std::uint8_t;</div><div class="line">        <span class="keyword">using</span> iterator_category = std::input_iterator_tag;</div><div class="line">        <span class="keyword">using</span> pointer = std::uint8_t*;</div><div class="line">        <span class="keyword">using</span> reference = std::uint8_t&amp;;</div><div class="line">        <span class="keyword">using</span> difference_type = std::ptrdiff_t;</div><div class="line"></div><div class="line">        <span class="comment">// Operator * can be used to perform the actual reading</span></div><div class="line">        std::uint8_t operator * () {</div><div class="line">            std::uint8_t x;</div><div class="line">            *m_stream &gt;&gt; x;</div><div class="line">            <span class="keywordflow">return</span> x;</div><div class="line">        }</div><div class="line">        <span class="comment">// The increment operator can be a NOP</span></div><div class="line">        InIter&amp; operator ++ () { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        std::istream* m_stream;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>OutIter {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        OutIter (std::ostream&amp; os) : m_stream (&amp;os) {}</div><div class="line">        OutIter (OutIter&amp;&amp; src) = <span class="keywordflow">default</span>;</div><div class="line">        OutIter&amp; operator = (OutIter&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Type Definitions for std::iterator_traits</span></div><div class="line">        <span class="keyword">using</span> value_type = std::uint8_t;</div><div class="line">        <span class="keyword">using</span> iterator_category = std::output_iterator_tag;</div><div class="line">        <span class="keyword">using</span> pointer = std::uint8_t*;</div><div class="line">        <span class="keyword">using</span> reference = std::uint8_t&amp;;</div><div class="line">        <span class="keyword">using</span> difference_type = std::ptrdiff_t;</div><div class="line"></div><div class="line">        <span class="comment">// To allow &quot;(*iter)=x&quot;, simply return *this.</span></div><div class="line">        OutIter&amp; operator * () {</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// Do the actual writing</span></div><div class="line">        <span class="keywordtype">void</span> operator = (std::uint8_t x) {</div><div class="line">            *m_stream &lt;&lt; x;</div><div class="line">        }</div><div class="line">        <span class="comment">// The increment operator can be a NOP</span></div><div class="line">        OutIter&amp; operator ++ () {</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        std::ostream* m_stream;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Open input file</span></div><div class="line">        std::ifstream input (<span class="stringliteral">&quot;rawdata.be&quot;</span>, std::ios::binary);</div><div class="line">        <span class="keywordflow">if</span> (!input)</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;File could not be opened&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Determine file size</span></div><div class="line">        input.seekg (0, std::ios::end);</div><div class="line">        std::size_t fSize = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span> (input.tellg ());</div><div class="line">        input.seekg (0, std::ios::beg);</div><div class="line"></div><div class="line">        std::uint32_t x;</div><div class="line">        <span class="comment">// Read a 32-Bit-Integer as big endian</span></div><div class="line">        uSer::deserialize&lt;uSer::ByteOrder::BE&gt; (InIter { input }, x, fSize);</div><div class="line"></div><div class="line">        <span class="comment">// Open output file</span></div><div class="line">        std::ofstream output (<span class="stringliteral">&quot;rawdata.le&quot;</span>, std::ios::binary);</div><div class="line">        output.exceptions (std::ofstream::failbit);</div><div class="line"></div><div class="line">        <span class="comment">// Write the integer as little endian</span></div><div class="line">        uSer::serialize&lt;uSer::ByteOrder::LE&gt; (OutIter (output), x, uSer::infSize);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">        <span class="comment">// Handle errors</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex26"></a>
Deserializing a vector of integers from an array.</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array with the raw binary data.</span></div><div class="line">    <span class="keyword">const</span> std::uint8_t raw [4] { 0x54, 0x45, 0x53, 0x54 };</div><div class="line">    <span class="comment">// Define a vector to receive the deserialized data and allocate it to the desired size.</span></div><div class="line">    std::vector&lt;std::uint16_t&gt; x (2);</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual deserialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line">        <span class="comment">// Write the data to standard output.</span></div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; x [0] &lt;&lt; <span class="stringliteral">&quot;, 0x&quot;</span> &lt;&lt; x [1] &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex27"></a>
Defining dynamic data structures with Dyn::Size</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>A;</div><div class="line">std::size_t g_getSize (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp;);</div><div class="line"></div><div class="line"><span class="comment">// Functional for determining the dynamic size (class with operator () overloaded)</span></div><div class="line"><span class="keyword">struct </span>Functional {</div><div class="line">    std::size_t operator () (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp;);</div><div class="line">} functional;</div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Member function for determining the dynamic size</span></div><div class="line">    std::size_t m_getSize ()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> N2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Size of array1</span></div><div class="line">    std::uint16_t N1;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array</span></div><div class="line">    std::uint8_t array1 [20];</div><div class="line">    <span class="comment">// Define the array size dynamically using a member variable</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (array1, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;A::N1&gt;)</div><div class="line"></div><div class="line">    std::uint16_t N2;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array</span></div><div class="line">    std::uint8_t array2 [20];</div><div class="line">    <span class="comment">// Define the array size dynamically using a member function</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (array2, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;A::m_getSize&gt;)</div><div class="line"></div><div class="line">    std::uint16_t N3;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array</span></div><div class="line">    std::uint8_t array3 [20];</div><div class="line">    <span class="comment">// Define the array size dynamically using a free function</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (array3, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;g_getSize&gt;)</div><div class="line"></div><div class="line">    std::uint16_t N4;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array</span></div><div class="line">    std::uint8_t array4 [20];</div><div class="line">    <span class="comment">// Define the array size dynamically using a functional (class with operator () overloaded)</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (array4, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;functional&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (N1, array1, N2, array2, N3, array3, N4, array4)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Free function for determining the dynamic size</span></div><div class="line">std::<span class="keywordtype">size_t</span> g_getSize (const struct A&amp; a) {</div><div class="line">    <span class="keywordflow">return</span> a.N3;</div><div class="line">}</div><div class="line"></div><div class="line">std::size_t Functional::operator () (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp; a) {</div><div class="line">    <span class="keywordflow">return</span> a.N4;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array with binary data</span></div><div class="line">    <span class="keyword">const</span> std::uint8_t raw [26] = { 0x03, 0x00, 0x01, 0x02, 0x03,</div><div class="line">                                        0x04, 0x00, 0x01, 0x02, 0x03, 0x04,</div><div class="line">                                        0x05, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,</div><div class="line">                                        0x06, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };</div><div class="line">    <span class="comment">// Define a struct to receive the deserialized data</span></div><div class="line">    A x;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual deserialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line"></div><div class="line">        <span class="comment">// Write the read data to standard output.</span></div><div class="line"></div><div class="line">        std::copy (x.array1, x.array1 + x.N1, std::ostream_iterator&lt;int&gt; (std::cout, <span class="stringliteral">&quot;, &quot;</span>)); std::cout &lt;&lt; std::endl;</div><div class="line">        std::copy (x.array2, x.array2 + x.N2, std::ostream_iterator&lt;int&gt; (std::cout, <span class="stringliteral">&quot;, &quot;</span>)); std::cout &lt;&lt; std::endl;</div><div class="line">        std::copy (x.array3, x.array3 + x.N3, std::ostream_iterator&lt;int&gt; (std::cout, <span class="stringliteral">&quot;, &quot;</span>)); std::cout &lt;&lt; std::endl;</div><div class="line">        std::copy (x.array4, x.array4 + x.N4, std::ostream_iterator&lt;int&gt; (std::cout, <span class="stringliteral">&quot;, &quot;</span>)); std::cout &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex28"></a>
Defining optional data structures with Dyn::Optional</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>A;</div><div class="line"><span class="keywordtype">bool</span> g_getSize (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp;);</div><div class="line"></div><div class="line"><span class="comment">// Functional for determining the existence (class with operator () overloaded)</span></div><div class="line"><span class="keyword">struct </span>Functional {</div><div class="line">    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp;);</div><div class="line">} functional;</div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Member function for determining whether an object is present</span></div><div class="line">        <span class="keywordtype">bool</span> m_getSize ()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> N2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// 1 if v1 exists, 0 else</span></div><div class="line">    std::uint8_t N1;</div><div class="line"></div><div class="line">    <span class="comment">// Define an optional object</span></div><div class="line">    std::uint8_t v1;</div><div class="line">    <span class="comment">// Define the presence of an object to be optional using a member variable</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (v1, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Optional&lt;&amp;A::N1&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// 1 if v2 exists, 0 else</span></div><div class="line">    std::uint8_t N2;</div><div class="line"></div><div class="line">    <span class="comment">// Define an optional object</span></div><div class="line">    std::uint8_t v2;</div><div class="line">    <span class="comment">// Define the presence of an object to be optional using a member function</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (v2, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Optional&lt;&amp;A::m_getSize&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// 1 if v3 exists, 0 else</span></div><div class="line">    std::uint8_t N3;</div><div class="line"></div><div class="line">    <span class="comment">// Define an optional object</span></div><div class="line">    std::uint8_t v3;</div><div class="line">    <span class="comment">// Define the presence of an object to be optional using a free function</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (v3, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Optional&lt;&amp;g_getSize&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// 1 if v4 exists, 0 else</span></div><div class="line">    std::uint8_t N4;</div><div class="line"></div><div class="line">    <span class="comment">// Define an optional object</span></div><div class="line">    std::uint8_t v4;</div><div class="line">    <span class="comment">// Define the presence of an object to be optional using a functional (class with operator () overloaded)</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (v4, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Optional&lt;&amp;functional&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (N1, v1, N2, v2, N3, v3, N4, v4)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Free function for determining the presence</span></div><div class="line"><span class="keywordtype">bool</span> g_getSize (const struct A&amp; a) {</div><div class="line">    <span class="keywordflow">return</span> a.N3 != 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> Functional::operator () (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp; a) {</div><div class="line">    <span class="keywordflow">return</span> a.N4 != 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array with binary data</span></div><div class="line">    <span class="keyword">const</span> std::uint8_t raw [6] = {  0x01, 0x01,</div><div class="line">                                    0x00,</div><div class="line">                                    0x01, 0x2A,</div><div class="line">                                    0x00 };</div><div class="line">    <span class="comment">// Define a struct to receive the deserialized data</span></div><div class="line">    A x;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual deserialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line"></div><div class="line">        <span class="comment">// Write the read data to standard output.</span></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (x.N1) std::cout &lt;&lt; <span class="stringliteral">&quot;v1: &quot;</span> &lt;&lt; std::hex &lt;&lt; int (x.v1) &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (x.N2) std::cout &lt;&lt; <span class="stringliteral">&quot;v2: &quot;</span> &lt;&lt; std::hex &lt;&lt; int (x.v2) &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (x.N3) std::cout &lt;&lt; <span class="stringliteral">&quot;v3: &quot;</span> &lt;&lt; std::hex &lt;&lt; int (x.v3) &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (x.N4) std::cout &lt;&lt; <span class="stringliteral">&quot;v4: &quot;</span> &lt;&lt; std::hex &lt;&lt; int (x.v4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="Ex29"></a>
Defining hook funktions to be called before/after (de)serialization</h1>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>A;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> serPost (<span class="keyword">const</span> uint8_t&amp;, <span class="keyword">const</span> A&amp;);</div><div class="line"></div><div class="line"><span class="comment">// Functional to be called before deserialization</span></div><div class="line"><span class="keyword">struct </span>DeSerPre {</div><div class="line">    <span class="keywordtype">void</span> operator () (uint8_t&amp;, A&amp;);</div><div class="line">} deSerPre;</div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Member function to be called before serialization</span></div><div class="line">    <span class="keywordtype">void</span> serPre (<span class="keyword">const</span> uint8_t&amp; a)<span class="keyword"> const </span>{</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;SerPre\n&quot;</span>;</div><div class="line">        <span class="comment">// Simulate an error condition</span></div><div class="line">        <span class="keywordflow">if</span> (a != 42)</div><div class="line">            <span class="keywordflow">throw</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a> (<a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2abadcb3f06ddb8821cd593f31234c23733b">uSer_EHOOK</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Member function to be called after deserialization</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> deSerPost () {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DeSerPost\n&quot;</span>;</div><div class="line">        <span class="comment">// Simulate an error condition</span></div><div class="line">        <span class="keywordflow">return</span> a == 42 ? <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a> : <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2abadcb3f06ddb8821cd593f31234c23733b">uSer_EHOOK</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Begin declaration. Define hook to be called after deserialization of the whole struct.</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="structuSer_1_1Hook_1_1DeSerPost.html">uSer::Hook::DeSerPost&lt;&amp;A::deSerPost&gt;</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define some members</span></div><div class="line">    std::uint8_t a, b, c;</div><div class="line"></div><div class="line">    <span class="comment">// Define hooks to be called before/after (de)serialization of the individual members</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(a, <a class="code" href="namespaceuSer.html">uSer</a>::Hook::SerPre&lt;&amp;A::serPre&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(b, <a class="code" href="namespaceuSer.html">uSer</a>::Hook::SerPost&lt;&amp;serPost&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(c, <a class="code" href="namespaceuSer.html">uSer</a>::Hook::DeSerPre&lt;&amp;deSerPre&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Hook function to be called after serialization</span></div><div class="line"><span class="keywordtype">void</span> serPost (const uint8_t&amp;, const A&amp;) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;SerPost\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> DeSerPre::operator () (uint8_t&amp;, A&amp;) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DeSerPre\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [3];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 42, 2, 3 };</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Serialize &amp; deserialize</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">        <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="ExC"></a>
Using µSer in C projects</h1>
<h2><a class="anchor" id="ExC_Hdr"></a>
Common header file for data structures</h2>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define data structures compatible with both C and C++.</span></div><div class="line"></div><div class="line"><span class="comment">// Define a simple struct containing integers</span></div><div class="line"><span class="keyword">struct </span>PacketA {</div><div class="line">    <span class="comment">// Begin struct definition</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a>(PacketA, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    uint32_t a;</div><div class="line">    <span class="comment">// Encode a in Big-Endian in the raw data</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(a, <a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line"></div><div class="line">    uint16_t b;</div><div class="line">    int8_t c;</div><div class="line">    <span class="comment">// Encode c in signed-magnitude format in the raw data</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(c, <a class="code" href="namespaceuSer.html">uSer</a>::SignFormat::SignedMagnitude)</div><div class="line"></div><div class="line">    <span class="comment">// List members</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Define a struct containing a dynamic data structure. Use the &quot;typedef struct&quot;-Trick to make usage more convenient.</span></div><div class="line">typedef struct PacketB_ {</div><div class="line">    <span class="comment">// Begin struct definition</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (PacketB_, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    uint8_t N;</div><div class="line">    struct PacketA packets [8];</div><div class="line">    <span class="comment">// Let N denote the size of the arra packets.</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (packets, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;PacketB_::N&gt;)</div><div class="line"></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (N, packets)</div><div class="line">} PacketB;</div><div class="line"></div><div class="line"><span class="comment">// Declare functions for (de)serialization of the data structure. These will be implemented as C++.</span></div><div class="line"></div><div class="line"><a class="code" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> serializePacketB (uint8_t* raw, const PacketB* pk, <span class="keywordtype">size_t</span> bufferSize);</div><div class="line"><a class="code" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> deserializePacketB (const uint8_t* raw, PacketB* pk, <span class="keywordtype">size_t</span> bufferSize);</div></div><!-- fragment --> <h2><a class="anchor" id="ExC_Ser"></a>
Implementation of the C++ serialization functions</h2>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;packet.h&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> serializePacketB (uint8_t* raw, <span class="keyword">const</span> PacketB* pk, <span class="keywordtype">size_t</span> bufferSize) {</div><div class="line">    <span class="comment">// Just call the µSer serialization function</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, *pk, bufferSize);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> deserializePacketB (<span class="keyword">const</span> uint8_t* raw, PacketB* pk, <span class="keywordtype">size_t</span> bufferSize) {</div><div class="line">    <span class="comment">// Just call the µSer deserialization function</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, *pk, bufferSize);</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="ExC_main"></a>
Calling serialization functions from C code</h2>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;inttypes.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;packet.h&quot;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a packet instance and fill it with some data</span></div><div class="line">    PacketB pk;</div><div class="line">    pk.N = 2;</div><div class="line">    pk.packets [0].a = 0xDEADBEEF;</div><div class="line">    pk.packets [0].b = 0xAA55;</div><div class="line">    pk.packets [0].c = -42;</div><div class="line"></div><div class="line">    pk.packets [1].a = 0xC0FEBABE;</div><div class="line">    pk.packets [1].b = 0x1234;</div><div class="line">    pk.packets [1].c = 35;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array to receive the raw data</span></div><div class="line">    uint8_t raw [15];</div><div class="line">    <span class="comment">// Serialize the packet into the raw data</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> ec = serializePacketB (raw, &amp;pk, <span class="keyword">sizeof</span> (raw) <span class="comment">/* uint8_t always has size 1 */</span>);</div><div class="line">    <span class="comment">// Check for errors</span></div><div class="line">    <span class="keywordflow">if</span> (ec != <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a>) {</div><div class="line">        fprintf (stderr, <span class="stringliteral">&quot;Serialization error: %s\n&quot;</span>, <a class="code" href="uSer_8hh.html#ae554bbbb88b9dd386e21dda79645dca1">uSer_getErrorMessage</a> (ec));</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// Print the raw data</span></div><div class="line">        puts (<span class="stringliteral">&quot;Serialization result:&quot;</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <span class="keyword">sizeof</span>(raw); ++i) {</div><div class="line">            printf (<span class="stringliteral">&quot;%02x, &quot;</span>, raw [i]);</div><div class="line">        }</div><div class="line">        puts (<span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Deserialize the raw data back into the struct</span></div><div class="line">    ec = deserializePacketB (raw, &amp;pk, <span class="keyword">sizeof</span> (raw));</div><div class="line">    <span class="comment">// Check for errors</span></div><div class="line">    <span class="keywordflow">if</span> (ec != <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a>) {</div><div class="line">        fprintf (stderr, <span class="stringliteral">&quot;Deserialization error: %s\n&quot;</span>, <a class="code" href="uSer_8hh.html#ae554bbbb88b9dd386e21dda79645dca1">uSer_getErrorMessage</a> (ec));</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// Print the deserialized data structure</span></div><div class="line">        puts (<span class="stringliteral">&quot;Deserialization result:&quot;</span>);</div><div class="line"></div><div class="line">        printf (<span class="stringliteral">&quot;pk.N=%&quot;</span> PRIu8 <span class="stringliteral">&quot;\n&quot;</span>, pk.N);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; pk.N; ++i) {</div><div class="line">            printf (<span class="stringliteral">&quot;pk.packets[%zd].a=%&quot;</span> PRIx32 <span class="stringliteral">&quot;, .b=%&quot;</span> PRIx16 <span class="stringliteral">&quot;, .c=%&quot;</span> PRId8 <span class="stringliteral">&quot;\n&quot;</span>, i, pk.packets [i].a, pk.packets [i].b, pk.packets [i].c);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">µSer Serialization Library</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
