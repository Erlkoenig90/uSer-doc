<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>µSer: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">µSer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ConDataStr">Data Structures</a></li>
<li class="level1"><a href="#ConRaw">Raw Data</a></li>
<li class="level1"><a href="#ConAttr">Attributes</a></li>
<li class="level1"><a href="#ConAPI">The serialize and deserialize functions</a><ul><li class="level2"><a href="#ConError">Error Handling</a></li>
</ul>
</li>
<li class="level1"><a href="#ConStructAnnot">Defining and Annotating structs</a><ul><li class="level2"><a href="#ConStruct1">Defining and annotating struct members separately</a></li>
<li class="level2"><a href="#ConStruct2">Annotating a whole struct</a></li>
<li class="level2"><a href="#ConStruct3">Annotating a single struct member</a></li>
<li class="level2"><a href="#ConStruct4">Defining and annotating a single member in one step</a></li>
<li class="level2"><a href="#ConStruct5">Defining and annotating all struct members in one step</a></li>
<li class="level2"><a href="#ConStruct6">Non-Intrusive struct annotation</a></li>
</ul>
</li>
<li class="level1"><a href="#ConBO">Byte Order</a></li>
<li class="level1"><a href="#ConSF">Sign Formats</a></li>
<li class="level1"><a href="#ConWidth">Integer Sizes</a></li>
<li class="level1"><a href="#ConPadding">Padding</a></li>
<li class="level1"><a href="#ConIter">Raw Iterators</a><ul><li class="level2"><a href="#ConIter1">Input Iterators with no padding bytes</a></li>
<li class="level2"><a href="#ConIter2">Output Iterators with no padding bytes</a></li>
<li class="level2"><a href="#ConIter3">Input Iterators with padding bytes and without operator +=</a></li>
<li class="level2"><a href="#ConIter4">Input Iterators with padding bytes and with operator +=</a></li>
<li class="level2"><a href="#ConIter5">Output Iterator with padding bytes and T::iterator_category = std::output_iterator_tag</a></li>
<li class="level2"><a href="#ConIter6">Output Iterator with padding bytes, without operator += and T::iterator_category = std::forward_iterator_tag</a></li>
<li class="level2"><a href="#ConIter7">Output Iterator with padding bytes, with operator += and T::iterator_category = std::forward_iterator_tag</a></li>
</ul>
</li>
<li class="level1"><a href="#ConDyn">Dynamic data structures</a><ul><li class="level2"><a href="#ConDyn1">Containers with dynamic size</a></li>
<li class="level2"><a href="#ConDyn2">Dynamic size of struct members via Dyn::Size</a></li>
<li class="level2"><a href="#ConDyn3">Optional struct members via Dyn::Optional</a></li>
</ul>
</li>
<li class="level1"><a href="#ConHooks">Hooks</a></li>
<li class="level1"><a href="#ConBufSize">Calculating buffer sizes</a></li>
<li class="level1"><a href="#Minimize">Using µSer on resource-constrained systems</a></li>
<li class="level1"><a href="#CCompat">C-Compatibility</a></li>
</ul>
</div>
<div class="textblock"><p>This page explains all concepts of using µSer.</p>
<h1><a class="anchor" id="ConDataStr"></a>
Data Structures</h1>
<p>µSer's main task is to deal with different kind of data structures designed by the library's user. The object passed to <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> serialize or <a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> deserialize is the root of a tree-like data structure. The leaves are always integral or enum types, and the inner nodes various kinds of containers - similar to e.g. JSON, but the structure is fixed by the application's source code.</p>
<p>All standard integral types are supported by µSer: bool, char, char16_t, char32_t, wchar_t, short, int, long, long long and signed/unsigned variants. All extension types for which std::numeric_limits, std::is_signed_v and std::is_unsigned_v are specialized and for which std::is_integral_v&lt;T&gt; is true work as well. Enumeration types are casted to/from their underlying integral type for (de)serialization.</p>
<p>Integers may be stored inside container types, which in turn can be stored in more containers. µSer supports different kinds of containers: C-Arrays, std::array and all other homogeneous containers supporting iterators as well as structs that have non-static member variables, std::tuple and std::pair, which can be considered heterogeneous containers. µSer never resizes containers - before deserialization, the user has to allocate elements that µSer will write to. Structs have to be <a class="el" href="tutorial.html#ConStructAnnot">annotated</a> to make their members known to µSer; all other containers can be directly used. The contained elements are (de)serialized consecutively.</p>
<p>We have already seen how to serialize an integer: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>µSer only supports unsigned integers in the raw data, as bit operations on signed integers would be largely platform-dependent. Unfortunately, C++'s I/O functions usually work on "char", which might be signed. Converting unsigned to signed data is platform-dependent (see paragraph [conv.integral] in the C++ Standard), so converting each element of the raw data individually is not a solution. Using reinterpret_cast to convert the pointer to unsigned data into a pointer to signed data is implementation-defined as well. Since it keeps the bit patterns intact, it can be expected to transfer the bits of the unsigned data directly to/from the file and works on all major platforms. This method will be used in all further examples; the user code has to make sure that the (de)serialized unsigned integers are correctly read/written on the target platform.</dd></dl>
<p>Serializing a container essentially works the same way:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::array&lt;std::uint16_t, 2&gt; x {{ 0x4554, 0x5453 }};</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>This example outputs "TEST" too, but this time we packed two bytes into one 16-Bit-Integer.</p>
<p>Tuples allow us to combine values of different types: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::tuple&lt;std::uint16_t, std::uint8_t, std::uint8_t&gt; x { 0x4554, 0x53, 0x54 };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> The output still stays the same.</p>
<p>Until now, µSer was able to check at compile time whether the data fits into the raw array, since the sizes of both are fixed. This is not possible when a container of dynamic size, such as std::vector, is used. In that case the container might be too large to fit into the raw data array. µSer then automatically implements a size check to prevent buffer overflow. To react to an error condition appropriately, we need to implement some error handling. The easiest way to do that is to defined the macro <a class="el" href="optional_8cpp.html#ac62717affc27361b1479a8beeb13abfc">USER_EXCEPTIONS</a> <em>before</em> including the <a class="el" href="uSer_8hh.html">uSer.hh file</a> to enable exception support, and catch the exceptions:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::uint16_t&gt; x { 0x4554, 0x5453 };</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual serialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">        <span class="comment">// Write the binary data to standard output.</span></div><div class="line">        std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Adding another element to the vector will provoke the error. See <a class="el" href="tutorial.html#ConError">Error Handling</a> for more information. As serializing structs needs some extra work, it is documented in <a class="el" href="tutorial.html#ConStructAnnot">Defining and Annotating structs</a>.</p>
<h1><a class="anchor" id="ConRaw"></a>
Raw Data</h1>
<p>Before we dive further into the API documentation, we need to think about how data is mapped from the raw binary stream to the C++ data structures. This is merely conceptual; µSer does calculations on whole integers and not individual bits.</p>
<p>As stated previously, µSer (de)serializes data to/from a stream of unsigned integers of equal type. We will call these integers "serialization word" or short "SWord". Typically, std::uint8_t or unsigned char will be used here. Depending on the architecture, using a larger type may improve performance, particularly if the size of a SWord corresponds to the register size of the processor. For example, on a 32-Bit-Architecture std::uint32_t may yield best results. However, since the size of the elements of <a class="el" href="tutorial.html#ConDyn">dynamic data structures</a> must be a multiple of the SWord size, the size of the SWord may not be chosen arbitrarily depending on the data structures.</p>
<p>The raw binary in/out data is seen as a stream of bits which are made up of the sequence of SWords. The least significant bit of the SWords always comes first, and the most significant one comes last. If you serialize some data into a std::uint8_t stream, then combine pairs of those into std::uint16_t integers in a little endian fashion and deserialize the resulting stream, you should end up with the same data. If some communication channel combines 8-Bit-Integers into 16-Bit-Integers in a big endian fashion, the above rule would be violated - bits 8-16 of the first integer would come first, and then bits 0-7. To deserialize such a data stream, you have to swap the bytes manually or by calling <a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> a second time (see below for explanation of the API usage):</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    std::tuple&lt;std::uint16_t, std::uint8_t, std::uint8_t&gt; x { 0x4554, 0x53, 0x54 };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Simulate a communication channel which combines the 8-Bit-Integers into 16-Bit-Integers</span></div><div class="line">    <span class="comment">// in a big endian way:</span></div><div class="line">    std::uint16_t raw2 [2];</div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; <span class="keyword">sizeof</span>(raw)/2 <span class="comment">/* uint8_t always has size 1 */</span>; ++i) {</div><div class="line">        raw2[i] = <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span> ((uint16_t { raw[i*2] } &lt;&lt; 8) | raw [i*2+1]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Turn the swapped 16-Bit-Words back into a sequence of words where the least significant bit comes first</span></div><div class="line">    std::uint16_t raw3 [2];</div><div class="line">    uSer::deserialize&lt;uSer::ByteOrder::BE&gt; (raw2, raw3);</div><div class="line"></div><div class="line">    <span class="comment">// Actually deserialize the data</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw3, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the data to standard output. We need to convert the uint8_t elements into integers,</span></div><div class="line">    <span class="comment">// because else they will be interpreted as individual characters.</span></div><div class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; std::get&lt;0&gt; (x) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { std::get&lt;1&gt; (x) } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { std::get&lt;2&gt; (x) } &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The bits in one serialization word can be configured by the <a class="el" href="structuSer_1_1RawInfo.html">uSer::RawInfo</a> attribute. This can be used to e.g. serialize data into 7-bit-Words or other word sizes for which the platform offers no integer type. The serialization word type must be large enough to store those bits.</p>
<p>Of the tree formed by the C++ data structure, only the leaves, i.e. the integers (or enums converted to integers) are mapped to the bit stream. No meta information about the types or container sizes is written or read such that the application can implement most given formats. In essence, all integers and enums in the data structure are mapped to a "flat" sequence of integers of different size whose bits are then mapped to the raw data stream. An integer may be split into bytes whose order can be configured as the <a class="el" href="tutorial.html#ConBO">byte order</a> (usually <a class="el" href="structuSer_1_1ByteOrder_1_1LE.html">little</a> or <a class="el" href="structuSer_1_1ByteOrder_1_1BE.html">big</a> endian). Of each byte the least significant bit is serialized first, and the most significant one last. This means that the bytes are always stored "forwards" in the raw data stream and never reversed. If individual integers or all SWords need to be reversed, this has to be done manually.</p>
<h1><a class="anchor" id="ConAttr"></a>
Attributes</h1>
<p>µSer's behaviour can be controlled by attributes. These are a set of types, some of them templates, that are passed via type parameters to µSer. There are never instances made of those types, and they provide no member functions for application code. Attributes are valid for one object. If they are used on a container type, they are applied to the contained elements. An exception are structs: Attributes applied to a struct are only used on the members if they are marked as inheritable. The easiest way to specify attributes is by passing them as template parameters to the <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">serialize</a> and <a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">serialize</a> functions:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint_least32_t x = 0x54534554;</div><div class="line">    <span class="comment">// Perform the actual serialization in Big Endian order.</span></div><div class="line">    uSer::serialize&lt;uSer::ByteOrder::BE, uSer::Width&lt;32&gt;&gt; (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The <a class="el" href="structuSer_1_1ByteOrder_1_1BE.html">uSer::ByteOrder::BE</a> attribute configures the <a class="el" href="tutorial.html#ConBO">byte order</a> to big endian, which reverses the string written to standard output. The <a class="el" href="structuSer_1_1Width.html">uSer::Width</a> attribute sets the size of the integer explicitly, see <a class="el" href="tutorial.html#ConWidth">Integer Sizes</a>. Entire structs and their members can be annotated with attributes as well, see <a class="el" href="tutorial.html#ConStructAnnot">below</a> for details.</p>
<p>The following attributes are available:</p>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>µSer Attributes</caption>
<tr>
<th>Category</th><th>Name</th><th>Default</th><th>Inheritable</th><th>Description </th></tr>
<tr>
<td rowspan="3">Byte Order </td><td><a class="el" href="structuSer_1_1ByteOrder_1_1LE.html">uSer::ByteOrder::LE</a></td><td align="center">✔</td><td align="center">✔</td><td>Serializes integers in little endian byte order, i.e. the least significant byte first.  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1ByteOrder_1_1BE.html">uSer::ByteOrder::BE</a></td><td></td><td align="center">✔</td><td>Serializes integers in big endian byte order, i.e. the most significant byte first.  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1ByteOrder_1_1PDP.html">uSer::ByteOrder::PDP</a></td><td></td><td align="center">✔</td><td>Serializes integers in PDP-endian byte order, i.e. serialize 32bit-Integers as two 16bit-integers, the most significant one first, and each internally as little endian.  </td></tr>
<tr>
<td rowspan="3">Sign Format </td><td><a class="el" href="structuSer_1_1SignFormat_1_1TwosComplement.html">uSer::SignFormat::TwosComplement</a></td><td align="center">✔</td><td align="center">✔</td><td>Stores signed integers in 2's complement, the standard for most architectures. The top half of the unsigned integer range is mapped on the negative numbers until -1, keeping the order.  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1SignFormat_1_1SignedMagnitude.html">uSer::SignFormat::SignedMagnitude</a></td><td></td><td align="center">✔</td><td>Stores signed integers in Signed-Magnitude format, i.e. an absolute value and a sign bit that defines whether the value is positive or negative.  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1SignFormat_1_1OnesComplement.html">uSer::SignFormat::OnesComplement</a></td><td></td><td align="center">✔</td><td>Stores signed integers in 1's complement, similar to Signed-Magnitude but the absolute value is bitwise negated for negative values.  </td></tr>
<tr>
<td rowspan="2">Padding </td><td><a class="el" href="structuSer_1_1Padding_1_1None.html">uSer::Padding::None</a></td><td align="center">✔</td><td align="center">✘</td><td>No additional dummy bits after integers.  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1Padding_1_1Fixed.html">uSer::Padding::Fixed</a></td><td></td><td align="center">✘</td><td>Stores a given fixed amount of bits after an integer, e.g. to accommodate alignment requirements.  </td></tr>
<tr>
<td rowspan="2">Dynamic Data </td><td><a class="el" href="structuSer_1_1Dyn_1_1Size.html">uSer::Dyn::Size</a></td><td></td><td align="center">✘</td><td>Define the size of a container depending on runtime information  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1Dyn_1_1Optional.html">uSer::Dyn::Optional</a></td><td></td><td align="center">✘</td><td>Define optional data objects depending on runtime information  </td></tr>
<tr>
<td rowspan="4">Hooks </td><td><a class="el" href="structuSer_1_1Hook_1_1SerPre.html">uSer::Hook::SerPre</a></td><td></td><td align="center">✘</td><td>Invoke a user-provided callback function <em>before</em> serializing an object  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1Hook_1_1SerPost.html">uSer::Hook::SerPost</a></td><td></td><td align="center">✘</td><td>Invoke a user-provided callback function <em>after</em> serializing an object  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1Hook_1_1DeSerPre.html">uSer::Hook::DeSerPre</a></td><td></td><td align="center">✘</td><td>Invoke a user-provided callback function <em>before</em> deserializing an object  </td></tr>
<tr>
<td><a class="el" href="structuSer_1_1Hook_1_1DeSerPost.html">uSer::Hook::DeSerPost</a></td><td></td><td align="center">✘</td><td>Invoke a user-provided callback function <em>after</em> deserializing an object  </td></tr>
<tr>
<td rowspan="1">Integer Width </td><td><a class="el" href="structuSer_1_1Width.html">uSer::Width</a></td><td></td><td align="center">✔</td><td>Manually define the size of an integer in bits  </td></tr>
<tr>
<td rowspan="1">SWord information </td><td><a class="el" href="structuSer_1_1RawInfo.html">uSer::RawInfo</a></td><td></td><td align="center">✘</td><td>Explicitly define the serialization word and optionally its size; useful if an iterator is used for which std::iterator_traits&lt;&gt;::value_type is not defined, e.g. std::back_insert_iterator. Only valid in the argument list of <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">serialize</a> and <a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">deserialize</a>.  </td></tr>
</table>
<p>The attributes belonging to one category are mutually exclusive; at maximum one of them may be defined on an object. If a sub-object has an attribute defined that conflicts with an inheritable attribute of a surrounding object, the attribute of the sub-object takes precedence. For example, if a struct is annotated with <a class="el" href="structuSer_1_1ByteOrder_1_1LE.html">uSer::ByteOrder::LE</a> but a member is annotated with <a class="el" href="structuSer_1_1ByteOrder_1_1BE.html">uSer::ByteOrder::BE</a>, the latter is effective for that member and its sub-objects, if any. The complete reference to attributes is found <a class="el" href="group__Attr.html">here</a>.</p>
<h1><a class="anchor" id="ConAPI"></a>
The serialize and deserialize functions</h1>
<p>The main entry points of µSer's API are the functions <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">serialize</a> and <a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">deserialize</a> which have several overloads to accommodate different use cases. The two functions have almost identical signatures that only differ in const-ness of the first two parameters. Because simply listing all overloads wouldn't be much help, we'll look at the functions on a more abstract level: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void|uSer_ErrorCode serialize   (raw, const obj [, size] , std::size_t* sizeUsed = nullptr)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;void|uSer_ErrorCode deserialize (const raw, obj [, size] , std::size_t* sizeUsed = nullptr)</div></div><!-- fragment --><p> The meaning of the parameters is:</p><ul>
<li>The "raw" parameter refers to the raw binary data stream. It can be a reference to a C-Array, std::array, a container providing a ".size()" member function, or an <a class="el" href="tutorial.html#ConIter">iterator</a> containing unsigned integers, the <a class="el" href="tutorial.html#ConRaw">serialization words</a>. For deserialize, the array/container or the target for the iterator may be const. µSer never allocates elements in output containers; the user has to make sure enough elements are available for writing, or use an iterator that appends as needed, such as std::back_insert_iterator.</li>
<li>The "obj" parameter is a reference to the <a class="el" href="tutorial.html#ConDataStr">C++ data structure</a> to be (de)serialized, i.e. an integer, enum, struct, std::pair, std::tuple or container supporting iterators. For serialize, the object may be const.</li>
<li><p class="startli">The "size" parameter specifies the size of the raw data stream, i.e. how many serialization words are available. It may be omitted if "raw" refers to a C-Array (an actual array, not a pointer to the first element), a std::array, or any container providing a ".size()" member function, in which case its size is used. The size may be specified in different ways:</p><ul>
<li>An integer of type std::size_t specifying the number of available serialization words.</li>
<li>An instance of <a class="el" href="structuSer_1_1DynSize.html">uSer::DynSize</a> containing a std::size_t; this is equivalent of specifying a naked std::size_t.</li>
<li>An instance of <a class="el" href="structuSer_1_1FixedSize.html">uSer::FixedSize</a>, conveniently obtained by writing "uSer::fixedSize&lt;N&gt;", signifying a compile-time known fixed buffer size.</li>
<li>An instance of <a class="el" href="structuSer_1_1InfSize.html">uSer::InfSize</a>, conveniently obtained by writing "uSer::infSize", signifying an infinite buffer size, e.g. a socket of file handle.</li>
</ul>
<p class="startli">When using <a class="el" href="structuSer_1_1FixedSize.html">uSer::FixedSize</a> for the size parameter or when using an array type for "raw", µSer can check the buffer size at compile time. If it is to small (excluding <a class="el" href="tutorial.html#ConDyn">dynamic data structures</a>), µSer will emit an error via static_assert.</p>
</li>
<li>The sizeUsed parameter is a pointer to std::size_t. If it is not a null pointer (the default), µSer will write the number of actually read/written serialization words to its target. This is useful when dynamic data structures are used.</li>
</ul>
<p>We have already seen how to serialize to arrays: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Serializing into a vector works similarly: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a vector to receive the raw binary data.</span></div><div class="line">    std::vector&lt;std::uint8_t&gt; raw (4);</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual serialization. Implicitly uses raw.size() to obtain the raw buffer size.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">        <span class="comment">// Write the binary data to standard output.</span></div><div class="line">        std::cout.write (reinterpret_cast&lt;char*&gt; (raw.data ()), 4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Note that the vector was initialized with 4 elements which are overwritten by serialize. If a number smaller than 4 were passed to std::vector's constructor, an exception would be thrown.</p>
<p>When "uSer::fixedSize&lt;N&gt;" is passed as the "size" parameter and the data structure contains no dynamic data, no runtime buffer range checks are performed, and no error handling is necessary: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a vector to receive the raw binary data.</span></div><div class="line">    std::vector&lt;std::uint8_t&gt; raw (4);</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x, uSer::fixedSize&lt;4&gt;);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw.data ()), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You have to ensure that the parameter to uSer::fixedSize matches the actually available data. If the buffer is actually smaller, undetected buffer overflows and security holes might occur!</dd></dl>
<p>We can pass a std::size_t or a <a class="el" href="structuSer_1_1DynSize.html">uSer::DynSize</a> as the size parameter to only (de)serialize a part of a container with a runtime-known size:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a vector to with the raw binary data.</span></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::uint8_t&gt; raw { 0xBE, 0xBA, 0xFE, 0xC0, 0xEF, 0xBE, 0xAD, 0xDE };</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Define a variable to receive the deserialized data</span></div><div class="line">        std::uint32_t x;</div><div class="line">        <span class="comment">// Perform the actual deserialization while using only the first half of the buffer.</span></div><div class="line">        uSer::deserialize&lt;uSer::RawInfo&lt;uint16_t, 8&gt;&gt; (raw, x, raw.size () / 2);</div><div class="line"><span class="comment">//      uSer::deserialize (raw, x, uSer::DynSize { raw.size () / 2 });  // Same functionality made explicit</span></div><div class="line"></div><div class="line">        <span class="comment">// Write the integer to standard output.</span></div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Since the size is not known in advance, error handling is required. When there is no explicit limit to the raw buffer size, we can pass "uSer::infSize" as the size argument. This can e.g. be used in combination with std::back_inserter to automatically grow the container as needed. Since µSer doesn't check the buffer size in this case, error handling is not needed unless other things require error handling (dynamic data structures). Unfortunately, the C++ Standard Library offers no way to determine the serialization word type from a given std::back_inserter_iterator type. Therefore, we have to explicitly pass the serialization word to the seralize function via the <a class="el" href="structuSer_1_1RawInfo.html">uSer::RawInfo</a> attribute:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a vector to receive the raw binary data.</span></div><div class="line">    std::vector&lt;std::uint8_t&gt; raw;</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line"></div><div class="line">    <span class="comment">// Perform the actual serialization; automatically append elements</span></div><div class="line">    <span class="comment">// to the raw vector without an explicit size limit.</span></div><div class="line">    uSer::serialize&lt;uSer::RawInfo&lt;std::uint8_t&gt;&gt; (std::back_inserter (raw), x, uSer::infSize);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;const char*&gt; (raw.data ()), static_cast&lt;std::streamsize&gt; (raw.size ())) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>This is also the first example where an <a class="el" href="tutorial.html#ConIter">iterator</a> instead of a reference to a container is passed to deserialize. </p>
<h2><a class="anchor" id="ConError"></a>
Error Handling</h2>
<p>The return type of serialize and deserialize depends on the parameters and is used to signal error conditions. If <a class="el" href="optional_8cpp.html#ac62717affc27361b1479a8beeb13abfc">USER_EXCEPTIONS</a> is defined <em>before</em> including the <a class="el" href="uSer_8hh.html">uSer.hh</a> header, exceptions are used to signal errors, and the return type will always be void. If it was not defined, and an error is possible (e.g. when using dynamic data structures or dynamic buffer sizes), the return type will be <a class="el" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> to signal success (<a class="el" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a>) or failure. If no errors can happen, the return type will be void. The <a class="el" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> enum is defined as "[[nodiscard]]" - if you ignore the returned value, the compiler will emit a warning. If you use the return value even if no errors are possible, you will get a compiler error. This prevents both forgetting to include error handling and superfluous error handling code.</p>
<p>We have already seen how to use exceptions: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::uint16_t&gt; x { 0x4554, 0x5453 };</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual serialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">        <span class="comment">// Write the binary data to standard output.</span></div><div class="line">        std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>When using return codes, you can user <a class="el" href="uSer_8hh.html#ae554bbbb88b9dd386e21dda79645dca1">uSer_getErrorMessage</a> to retrieve a string describing the error:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::uint16_t&gt; x { 0x4554, 0x5453 };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> ec = <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Check for success</span></div><div class="line">    <span class="keywordflow">if</span> (ec == <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a>) {</div><div class="line">        <span class="comment">// Write the binary data to standard output.</span></div><div class="line">        std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// Print error message</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; <a class="code" href="uSer_8hh.html#ae554bbbb88b9dd386e21dda79645dca1">uSer_getErrorMessage</a>(ec) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>If you were to ignore the returned value in this example, the compiler will issue a warning.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Exceptions are generally the better way to handle errors, as they allow to free resources automatically ("RAII") and pass errors through multiple levels of independently developed software components. They can also actually have a better performance than error codes, because program execution will directly jump to the catch-handlers in case of an error, while return codes have to be checked repeatedly to decide whether execution should continue or cancel. However, on small embedded systems, the runtime library for handling exceptions might be simply too large for the limited program memory, which is why you can disable exception handling in µSer. If you are programming for a PC or an embedded system running a "full" operating system like Linux/Android, using exceptions is probably the best way.</dd></dl>
<h1><a class="anchor" id="ConStructAnnot"></a>
Defining and Annotating structs</h1>
<p>In C++, struct and class are actually almost the same thing: Both keywords declare classes (technically, there are no structs in C++) with the only difference that members and base classes of classes declared by "struct" are public by default, and private for those declared by "class". However, it is customary to use "struct" for simple classes that only contain "flat" data without encapsulation mechanisms such as getter/setter functions, similar to how they are used in C. Therefore, we will call these classes "structs". Typically, most serializable data in applications is declared in such structs, e.g. to contain data for network packets or file headers. Therefore, structs play a central role in µSer.</p>
<p>Unlike with containers, tuples and arrays, there is no way to automatically get a list of the members of a struct. This makes it necessary to explicitly make the list of members known to µSer.</p>
<h2><a class="anchor" id="ConStruct1"></a>
Defining and annotating struct members separately</h2>
<p>The easiest way to do this is as follows:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line"><span class="comment">//  USER_STRUCT (A, uSer::AttrNone)</span></div><div class="line"></div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    std::uint32_t d;</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>First, the struct is defined as usual. Then a call to the <a class="el" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> macro is placed at the beginning. It requires one parameter, which is the name of the struct. There may be further parameters that define attributes valid for the whole struct. In this example, we don't provide any attributes. A strict compiler might emit a warning or error message because empty variadic macro parameters are not permitted by the C++ standard; in that case, we can pass <a class="el" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a> as a dummy meaning "no attributes".</p>
<h2><a class="anchor" id="ConStruct2"></a>
Annotating a whole struct</h2>
<p>Declaring attributes for a whole struct looks this way: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="structuSer_1_1ByteOrder_1_1BE.html">uSer::ByteOrder::BE</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    std::uint32_t d;</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> Now, all members of the struct are serialized as big endian.</p>
<h2><a class="anchor" id="ConStruct3"></a>
Annotating a single struct member</h2>
<p>A single member can be annotated by using <a class="el" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> : </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="structuSer_1_1ByteOrder_1_1BE.html">uSer::ByteOrder::BE</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    std::uint32_t d;</div><div class="line"></div><div class="line">    <span class="comment">// Annotate a member</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(d, <a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ConStruct4"></a>
Defining and annotating a single member in one step</h2>
<p>The definition and annotation of individual members can be combined by using <a class="el" href="uSer_8hh.html#aa698c0d67c4648448cff3db1230633fb">USER_MEM</a> : </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line"></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    <a class="code" href="uSer_8hh.html#aa698c0d67c4648448cff3db1230633fb">USER_MEM</a>(std::uint32_t, d, <a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line"></div><div class="line">    <span class="comment">// Annotate a member</span></div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> This method does not support arrays since their syntax requires parts of the type to be placed <em>after</em> the member name.</p>
<h2><a class="anchor" id="ConStruct5"></a>
Defining and annotating all struct members in one step</h2>
<p>The most compact method to declare structs is provided by <a class="el" href="uSer_8hh.html#a4b9dbf8cddfb3649be7fe5dabe720738">USER_DEF_MEM</a> : </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define and annotate multiple members</span></div><div class="line"></div><div class="line">    <a class="code" href="uSer_8hh.html#a4b9dbf8cddfb3649be7fe5dabe720738">USER_DEF_MEM</a>(</div><div class="line">            (std::uint16_t,a,<a class="code" href="namespaceuSer.html">uSer</a>::<a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">AttrNone</a>),</div><div class="line">            (std::uint16_t,b),</div><div class="line">            (std::uint8_t,c),</div><div class="line">            (std::uint32_t,d,<a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line">    )</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> This variant defines annotations for all members in one step. Again, we may have to use <a class="el" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a> to prevent empty variadic argument list. This variant does not support arrays either, but avoids typing every variable name twice.</p>
<h2><a class="anchor" id="ConStruct6"></a>
Non-Intrusive struct annotation</h2>
<p>The previously presented methods require the modification of the actual struct definition. They all add some some member types and static member functions to the struct whose names start with "uSer_". If the struct definition cannot be changed (e.g. because it belongs to an external library) or adding those members is not desirable (even though they have no influence on the struct's runtime behaviour), structs can be defined in a non-intrusive fashion. The macros used to achieve this have to be used in the <em>global</em> namespace. If the struct is defined in some namespace, its name has to be fully qualified.</p>
<p>Attributes valid for the whole struct can optionally be defined by <a class="el" href="uSer_8hh.html#a1038046f66eb6f26c458ed93f44e8883">USER_EXT_ANNOT</a> . If no attributes are needed, this macro can be omitted. Individual members can be annotated by <a class="el" href="uSer_8hh.html#a95a301f4f3647a9da1c54c64d88dab14">USER_EXT_MEM_ANNOT</a> . The only required macro is <a class="el" href="uSer_8hh.html#a568cacede8a3c880e8e9356243b76dd8">USER_EXT_ENUM_MEM</a>, which defines the list of members. </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>N {</div><div class="line">    <span class="comment">// Normal definition of a struct</span></div><div class="line">    <span class="keyword">struct </span>A {</div><div class="line">        <span class="comment">// Define arbitrary members</span></div><div class="line">        std::uint16_t a, b;</div><div class="line">        std::uint8_t c;</div><div class="line">        std::uint32_t d;</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// These macro calls need to be in the global scope.</span></div><div class="line"></div><div class="line"><span class="comment">// Optional: Define attributes for the whole struct.</span></div><div class="line"><a class="code" href="uSer_8hh.html#a1038046f66eb6f26c458ed93f44e8883">USER_EXT_ANNOT</a>(N::A, <a class="code" href="structuSer_1_1ByteOrder_1_1LE.html">uSer::ByteOrder::LE</a>)</div><div class="line"></div><div class="line"><span class="comment">// Optional: Annotate a struct member</span></div><div class="line"><a class="code" href="uSer_8hh.html#a95a301f4f3647a9da1c54c64d88dab14">USER_EXT_MEM_ANNOT</a>(N::A, d, <a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line"></div><div class="line"><span class="comment">// List all struct members</span></div><div class="line"><a class="code" href="uSer_8hh.html#a568cacede8a3c880e8e9356243b76dd8">USER_EXT_ENUM_MEM</a>(N::A, a, b, c, d)</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    N::A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>This can also be done in a more compact way by using <a class="el" href="uSer_8hh.html#a74c5c1444f1efe3192ece5bd7fb72556">USER_EXT_DEF_MEM</a> which defines and annotates all members at once. Attributes for the whole macro can again optionally be defined by <a class="el" href="uSer_8hh.html#a1038046f66eb6f26c458ed93f44e8883">USER_EXT_ANNOT</a> . </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>N {</div><div class="line">    <span class="comment">// Normal definition of a struct</span></div><div class="line">    <span class="keyword">struct </span>A {</div><div class="line">        <span class="comment">// Define arbitrary members</span></div><div class="line">        std::uint16_t a, b;</div><div class="line">        std::uint8_t c;</div><div class="line">        std::uint32_t d;</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// These macro calls need to be in the global scope.</span></div><div class="line"></div><div class="line"><span class="comment">// Optional: Define attributes for the whole struct.</span></div><div class="line"><a class="code" href="uSer_8hh.html#a1038046f66eb6f26c458ed93f44e8883">USER_EXT_ANNOT</a>(N::A, <a class="code" href="structuSer_1_1ByteOrder_1_1LE.html">uSer::ByteOrder::LE</a>)</div><div class="line"></div><div class="line"><span class="comment">// List all struct members</span></div><div class="line"><a class="code" href="uSer_8hh.html#a74c5c1444f1efe3192ece5bd7fb72556">USER_EXT_DEF_MEM</a>(N::A,</div><div class="line">        (a,<a class="code" href="namespaceuSer.html">uSer</a>::AttrNone),</div><div class="line">        (b),</div><div class="line">        (c),</div><div class="line">        (d,<a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE))</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    N::A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>It is actually possible to annotate any serializable type with <a class="el" href="uSer_8hh.html#a1038046f66eb6f26c458ed93f44e8883">USER_EXT_ANNOT</a> . Annotating general types such as "int" or "std::vector&lt;short&gt;" is however discouraged, since the annotation will be valid for any serialization process and might affect the behaviour of other parts of the program.</p>
<h1><a class="anchor" id="ConBO"></a>
Byte Order</h1>
<p>An important aspect for serializing integers is the byte order. Integers that have more bits than a byte need to be split into multiple bytes for storage. Most platforms enforce a particular byte order by storing integers in memory in a certain way. If the data is copied from memory and written to a file directly, that byte order is applied to the stored data as well. If that file is copied to a computer with a different byte order, loaded into memory directly, and processed by arithmetic operations, unexpected results may occur. The most popular byte order is <a class="el" href="structuSer_1_1ByteOrder_1_1LE.html">little endian</a>, where the least significant byte is stored first and the most significant one last. This byte order is e.g. used by x86 and most ARM platforms. The reverse case is <a class="el" href="structuSer_1_1ByteOrder_1_1BE.html">big endian</a>, where the most significant byte is stored first. This is used by PowerPC and in various internet protocols. <a class="el" href="structuSer_1_1ByteOrder_1_1PDP.html">PDP endian</a> is a hybrid variant, where 32-bit-Integers are split into two 16-bit-Integers, where the most significant one is stored first. The two 16-Bit-Integers are internally stored as little endian. This order stems from the PDP architecture.</p>
<p>For example, the number 305419896, or hexadecimal 0x12345678, is stored in the following orders (all numbers hexadecimal): </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Byte Order examples</caption>
<tr>
<th>Byte Order</th><th>Address 0</th><th>1</th><th>2</th><th>3 </th></tr>
<tr>
<td>Little Endian</td><td align="center">78</td><td>56</td><td>34</td><td>12 </td></tr>
<tr>
<td>Big Endian</td><td align="center">12</td><td>34</td><td>56</td><td>78 </td></tr>
<tr>
<td>PDP Endian</td><td align="center">34</td><td>12</td><td>78</td><td>56 </td></tr>
</table>
<p>µSer offers functionality to convert the data from the local platform's byte order into a specific defined order and back. The application code defines a fixed order desired for raw binary data, i.e. the network protocol or file format. µSer automatically converts the C++ data in the local order to/from that order. Since this is done via bit-operations, the order of the local platform need not be explicitly known and could actually be an entirely different one.</p>
<p>We have already seen how to use attributes to request a certain byte order: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="structuSer_1_1ByteOrder_1_1BE.html">uSer::ByteOrder::BE</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define arbitrary members</span></div><div class="line">    std::uint16_t a, b;</div><div class="line">    std::uint8_t c;</div><div class="line">    std::uint32_t d;</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c, d)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [9];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 0x1234, 0x4321, 0xAF, 0xDEADBEEF };</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> If no byte order is defined, µSer assumes little endian. If we serialize this struct on one platform and then deserialize it on another, µSer guarantees that the data in the integers is correct, regardless of the byte orders of the two platforms.</p>
<p>When the <a class="el" href="structuSer_1_1Width.html">Width</a> attribute is used to define an integer size that is not a multiple of a byte, the "incomplete" byte is assumed to contain the remaining most significant bits. In big endian order, this incomplete byte then comes first. Consider this example: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [2];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    std::uint16_t x = 0x765;</div><div class="line">    <span class="comment">// Serialize as little endian</span></div><div class="line">    uSer::serialize&lt;uSer::ByteOrder::LE, uSer::Width&lt;11&gt;&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Serialize as big endian</span></div><div class="line">    uSer::serialize&lt;uSer::ByteOrder::BE, uSer::Width&lt;11&gt;&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> The output is:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;0x65, 0x7, </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;0x2f, 0x3, </div></div><!-- fragment --><h1><a class="anchor" id="ConSF"></a>
Sign Formats</h1>
<p>Like with byte orders, different platforms have different ways to store negative values. µSer supports three of those: <a class="el" href="structuSer_1_1SignFormat_1_1TwosComplement.html">Two's complement</a>, <a class="el" href="structuSer_1_1SignFormat_1_1OnesComplement.html">One's complement</a> and <a class="el" href="structuSer_1_1SignFormat_1_1SignedMagnitude.html">Signed-Magnitude</a>.</p>
<p>The format two's complement takes the top half of the corresponding unsigned integer's range, and translates it into the negative numbers. For example, for a 16-Bit-Integer, the numbers 0-32767 stay as they are. The binary representation of the unsigned number 32768 means -32768 in two's complement, 32769 means -32767, and 65535 means -1. This is the most popular format used on most platforms, and the other two are rare.</p>
<p>The signed-magnitude format stores an absolute value and a sign bit that defines whether the value is positive or negative. This format corresponds to the usual decimal notation, where the a sign bit of "1" means "-" and "0" means "+". Inverting the sign bit means negating the value. This format has two representations for zero, i.e. +0 and -0.</p>
<p>The one's complement format is similar to signed-magnitude but the absolute value is bitwise negated for negative values. This format has two representations for zero as well. Inverting all bits means negating the number.</p>
<p>Just like the byte order, the application defines the desired sign format, and µSer converts the local format from/to the desired one. This works independently of the host's format. The ranges of the different formats are not equal: For example, 16-bit two's complement numbers have the range -32768 - 32767. 16-bit-Integers in the other two formats have the range -32767 - 32767. µSer uses static assertions to make sure the integer in the raw data fits into the local format. For example, if the local platform uses signed-magnitude, and you try to deserialize a 16-bit-integer in two's complement into a int16_t, you will get a compiler error, since -32768 can not be represented on the host platform.</p>
<p>This example serializes a signed integer in all three sign formats: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [2];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::int16_t x = -291;</div><div class="line"></div><div class="line">    <span class="comment">// Serialize as 2&#39;s complement</span></div><div class="line">    uSer::serialize&lt;uSer::SignFormat::TwosComplement&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Serialize as 1&#39;s complement</span></div><div class="line">    uSer::serialize&lt;uSer::SignFormat::OnesComplement&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Serialize as signed-magnitude</span></div><div class="line">    uSer::serialize&lt;uSer::SignFormat::SignedMagnitude&gt; (raw, x);</div><div class="line"></div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    <span class="keywordflow">for</span> (std::uint8_t r : raw)</div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; <span class="keywordtype">int</span> { r } &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> The output is: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;0xdd, 0xfe, </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;0xdc, 0xfe, </div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;0x23, 0x81,</div></div><!-- fragment --><h1><a class="anchor" id="ConWidth"></a>
Integer Sizes</h1>
<p>The different platforms support different integer sizes, but a protocol might require integers of a size for which no type exists. µSer allows to set a specific fixed size for an integer by using the <a class="el" href="structuSer_1_1Width.html">Width</a> attribute. The next integer will be serialized right after the previous one; integers need not start at a byte order. Essentially, this simulates bitfields in the binary data stream, without the need for actual C++ bitfields which behave in a non-portable way.</p>
<p>A simple example is to convert RGB565 color values into a single 16bit-Integer: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct for storing colors in RGB565 format.</span></div><div class="line"><span class="keyword">struct </span>Color {</div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (Color, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define color components.</span></div><div class="line">    std::uint8_t r, g, b;</div><div class="line"></div><div class="line">    <span class="comment">// Explicitly set the sizes of the integers</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(r, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;5&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(g, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;6&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(b, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;5&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (r, g, b)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Store the binary data in a 16bit-Integer</span></div><div class="line">    std::uint16_t raw [1];</div><div class="line">    <span class="comment">// Define a color to be serialized.</span></div><div class="line">    Color c1 { 24, 55, 12 };</div><div class="line">    <span class="comment">// Convert RGB565-Color into 16bit-Value</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, c1);</div><div class="line"></div><div class="line">    <span class="comment">// Output the raw value</span></div><div class="line">    std::cout &lt;&lt; std::hex &lt;&lt; std::setw(4) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; raw[0] &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="ConPadding"></a>
Padding</h1>
<p>Some formats require unused bits between the individual values. These are ignored during reading, and typically written to zero. These unused bits are called padding bits. While it is possible to define "dummy" integers (possibly using <a class="el" href="structuSer_1_1Width.html">uSer::Width</a> to achieve a specific amount of bits) that receive the padding bits, this wastes memory. Therefore, µSer provides the <a class="el" href="structuSer_1_1Padding_1_1Fixed.html">Padding::Fixed</a> attribute which can only be applied to integers, and specifies a fixed amount of padding bits that come after that integer.</p>
<p>Assuming we want to skip the "green" component from the previous color example, we can add 6 padding bits after the "red" one: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct for storing colors in RGB565 format.</span></div><div class="line"><span class="keyword">struct </span>Color {</div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (Color, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define color components.</span></div><div class="line">    std::uint8_t r, b;</div><div class="line"></div><div class="line">    <span class="comment">// Explicitly set the sizes of the integers</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(r, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;5&gt;, <a class="code" href="namespaceuSer.html">uSer</a>::Padding::Fixed&lt;6&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(b, <a class="code" href="namespaceuSer.html">uSer</a>::Width&lt;5&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (r, b)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Store the binary data in a 16bit-Integer</span></div><div class="line">    std::uint16_t raw [1];</div><div class="line">    <span class="comment">// Define a color to be serialized.</span></div><div class="line">    Color c1 { 24, 12 };</div><div class="line">    <span class="comment">// Convert RGB565-Color into 16bit-Value</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, c1);</div><div class="line"></div><div class="line">    <span class="comment">// Output the raw value</span></div><div class="line">    std::cout &lt;&lt; std::hex &lt;&lt; std::setw(4) &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; raw[0] &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> The remaining two values retain their position in the raw data, and the "gap" is filled with zero bits.</p>
<h1><a class="anchor" id="ConIter"></a>
Raw Iterators</h1>
<p>µSer accesses the raw data stream via iterators. In C++, an iterator is a small class that "refers" to an element in a container or an input/output stream. Unlike a simple index, an iterator instance knows which container it refers to. A pointer is the simplest kind of iterator, to be used with C-Arrays. The first parameter to the <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">serialize</a> and <a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">deserialize</a> functions is an iterator to the first raw data element (or a container/C-Array, of which the iterator to the first element will be queried using std::begin). µSer supports all standard library iterators that refer to unsigned integers, but it is possible to implement your own iterators to e.g. directly read/write the raw serialization words from/to some communication interface, network or file.</p>
<p>We can use std::istream_iterator and std::ostream_iterator to read/write raw data directly from/to files: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ios&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Open input file</span></div><div class="line">        std::ifstream input (<span class="stringliteral">&quot;rawdata.be&quot;</span>, std::ios::binary);</div><div class="line">        <span class="keywordflow">if</span> (!input)</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;File could not be opened&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Determine file size</span></div><div class="line">        input.seekg (0, std::ios::end);</div><div class="line">        std::size_t fSize = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span> (input.tellg ());</div><div class="line">        input.seekg (0, std::ios::beg);</div><div class="line"></div><div class="line">        std::uint32_t x;</div><div class="line">        <span class="comment">// Read a 32-Bit-Integer as big endian</span></div><div class="line">        uSer::deserialize&lt;uSer::ByteOrder::BE&gt; (std::istream_iterator&lt;std::uint8_t&gt; (input), x, fSize);</div><div class="line"></div><div class="line">        <span class="comment">// Open output file</span></div><div class="line">        std::ofstream output (<span class="stringliteral">&quot;rawdata.le&quot;</span>, std::ios::binary);</div><div class="line">        output.exceptions (std::ofstream::failbit);</div><div class="line"></div><div class="line">        <span class="comment">// Write the integer as little endian</span></div><div class="line">        uSer::serialize&lt;uSer::RawInfo&lt;std::uint8_t&gt;, <a class="code" href="structuSer_1_1ByteOrder_1_1LE.html">uSer::ByteOrder::LE</a>&gt; (std::ostream_iterator&lt;std::uint8_t&gt; (output), x, uSer::infSize);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">        <span class="comment">// Handle errors</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Note that <a class="el" href="structuSer_1_1RawInfo.html">RawInfo</a> is needed for the output operator, since µSer can't automatically determine the serialization word type from std::ostream_iterator. The iterators are instantiated with "std::uint8_t" since µSer needs unsigned integers in the raw stream. The file size is queried ahead of deserialization, as the input iterator doesn't signal end-of-file to µSer.</p>
<p>µSer's requirements for iterators are actually weaker than the standard library's, making it easy to write your own ones. With "T" being the iterator type, "iter" an instance of "T", and "x" an instance of the serialization word, the basic requirements imposed by µSer are:</p><ul>
<li>T needs to be move-constructible (i.e. have a constructor of the form "T::T (T&amp;&amp;)")</li>
<li>T needs to be move-assignable (i.e. have an assignment operator of the form "T&amp; operator = (T&amp;&amp;)")</li>
<li>T does not have to (but may) be default-constructible, copy-constructible or copy-assignable.</li>
<li>T needs the following member type definitions:<ul>
<li>"T::iterator_category" must be one of the standard iterator tag types; see the seven cases below for details.</li>
<li>"T::value_type" may be an alias for the serialization word type. If it is void, you must use <a class="el" href="structuSer_1_1RawInfo.html">RawInfo</a> to make that type known to µSer.</li>
<li>"T::difference_type" must be an integral type large enough to store the difference between two positions</li>
<li>"T::pointer" and "T::reference" must be a pointer/reference type to the serialization word or "void"; not used by µSer but required for std::iterator_traits&lt;T&gt; to work</li>
</ul>
</li>
<li>For <a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">deserialize</a>, "x = (*iter)" should return the current serialization word from the raw stream</li>
<li>For <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">serialize</a>, "(*iter) = x;" should write the next serialization word to the raw stream</li>
<li>"++iter" should advance the iterator to the next element</li>
</ul>
<p>If the raw binary stream contains bytes that consist entirely of padding bits, µSer is able to skip over those efficiently. There are seven cases for different kinds of iterators depending on whether padding bytes exist, each with their own set of guarantees and requirements:</p>
<h2><a class="anchor" id="ConIter1"></a>
Input Iterators with no padding bytes</h2>
<p>In this case, "T::iterator_category" is not used. µSer will call "*iter" and "++iter" in strictly alternating order, e.g.:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;x = *iter;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;++iter;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;x = *iter;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;++iter;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;x = *iter;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;++iter;</div></div><!-- fragment --><h2><a class="anchor" id="ConIter2"></a>
Output Iterators with no padding bytes</h2>
<p>In this case, "T::iterator_category" is not used. µSer will call "(*iter)=x" and "++iter" in strictly alternating order, e.g.:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;(*iter) = x;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;++iter;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;(*iter) = x;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;++iter;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;(*iter) = x;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;++iter;</div></div><!-- fragment --><p>This makes it easy to implement both input/output iterators, since the actual read/write can be done via the "operator *" while not doing anything in "operator ++". An example for both is:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ios&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>InIter {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        InIter (std::istream&amp; os) : m_stream (&amp;os) {}</div><div class="line">        InIter (InIter&amp;&amp; src) = <span class="keywordflow">default</span>;</div><div class="line">        InIter&amp; operator = (InIter&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Type Definitions for std::iterator_traits</span></div><div class="line">        <span class="keyword">using</span> value_type = std::uint8_t;</div><div class="line">        <span class="keyword">using</span> iterator_category = std::input_iterator_tag;</div><div class="line">        <span class="keyword">using</span> pointer = std::uint8_t*;</div><div class="line">        <span class="keyword">using</span> reference = std::uint8_t&amp;;</div><div class="line">        <span class="keyword">using</span> difference_type = std::ptrdiff_t;</div><div class="line"></div><div class="line">        <span class="comment">// Operator * can be used to perform the actual reading</span></div><div class="line">        std::uint8_t operator * () {</div><div class="line">            std::uint8_t x;</div><div class="line">            *m_stream &gt;&gt; x;</div><div class="line">            <span class="keywordflow">return</span> x;</div><div class="line">        }</div><div class="line">        <span class="comment">// The increment operator can be a NOP</span></div><div class="line">        InIter&amp; operator ++ () { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        std::istream* m_stream;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>OutIter {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        OutIter (std::ostream&amp; os) : m_stream (&amp;os) {}</div><div class="line">        OutIter (OutIter&amp;&amp; src) = <span class="keywordflow">default</span>;</div><div class="line">        OutIter&amp; operator = (OutIter&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Type Definitions for std::iterator_traits</span></div><div class="line">        <span class="keyword">using</span> value_type = std::uint8_t;</div><div class="line">        <span class="keyword">using</span> iterator_category = std::output_iterator_tag;</div><div class="line">        <span class="keyword">using</span> pointer = std::uint8_t*;</div><div class="line">        <span class="keyword">using</span> reference = std::uint8_t&amp;;</div><div class="line">        <span class="keyword">using</span> difference_type = std::ptrdiff_t;</div><div class="line"></div><div class="line">        <span class="comment">// To allow &quot;(*iter)=x&quot;, simply return *this.</span></div><div class="line">        OutIter&amp; operator * () {</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// Do the actual writing</span></div><div class="line">        <span class="keywordtype">void</span> operator = (std::uint8_t x) {</div><div class="line">            *m_stream &lt;&lt; x;</div><div class="line">        }</div><div class="line">        <span class="comment">// The increment operator can be a NOP</span></div><div class="line">        OutIter&amp; operator ++ () {</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        std::ostream* m_stream;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Open input file</span></div><div class="line">        std::ifstream input (<span class="stringliteral">&quot;rawdata.be&quot;</span>, std::ios::binary);</div><div class="line">        <span class="keywordflow">if</span> (!input)</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error (<span class="stringliteral">&quot;File could not be opened&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Determine file size</span></div><div class="line">        input.seekg (0, std::ios::end);</div><div class="line">        std::size_t fSize = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span> (input.tellg ());</div><div class="line">        input.seekg (0, std::ios::beg);</div><div class="line"></div><div class="line">        std::uint32_t x;</div><div class="line">        <span class="comment">// Read a 32-Bit-Integer as big endian</span></div><div class="line">        uSer::deserialize&lt;uSer::ByteOrder::BE&gt; (InIter { input }, x, fSize);</div><div class="line"></div><div class="line">        <span class="comment">// Open output file</span></div><div class="line">        std::ofstream output (<span class="stringliteral">&quot;rawdata.le&quot;</span>, std::ios::binary);</div><div class="line">        output.exceptions (std::ofstream::failbit);</div><div class="line"></div><div class="line">        <span class="comment">// Write the integer as little endian</span></div><div class="line">        uSer::serialize&lt;uSer::ByteOrder::LE&gt; (OutIter (output), x, uSer::infSize);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">        <span class="comment">// Handle errors</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ConIter3"></a>
Input Iterators with padding bytes and without operator +=</h2>
<p>In this case, "T::iterator_category" is not used. Two calls to "*iter" will never occur in direct succession, but multiple calls to "++iter" might directly follow each other to skip over padding bytes:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;x = *iter;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;++iter;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;x = *iter;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;++iter;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;++iter;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;x = *iter;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;++iter;</div></div><!-- fragment --><h2><a class="anchor" id="ConIter4"></a>
Input Iterators with padding bytes and with operator +=</h2>
<p>In this case, "T::iterator_category" is not used. With "n" being an instance of std::iterator_traits&lt;T&gt;::difference_type, "iter += n" should skip over n bytes. Two calls to "*iter" will never occur in direct succession, "++iter" will always follow "*iter", "iter += n" can optionally follow a "++iter", and "*iter" will follow either "++iter" or "iter += n", e.g.:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;x = *iter;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;++iter;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;x = *iter;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;++iter;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;iter += 2;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;x = *iter;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;++iter;</div></div><!-- fragment --><h2><a class="anchor" id="ConIter5"></a>
Output Iterator with padding bytes and T::iterator_category = std::output_iterator_tag</h2>
<p>In this case, µSer will call "(*iter)=x" and "++iter" in strictly alternating order and padding bytes will be written as zero, e.g.:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;*iter = x;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;++iter;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;*iter = 0;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;++iter;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;*iter = x;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;++iter;</div></div><!-- fragment --><h2><a class="anchor" id="ConIter6"></a>
Output Iterator with padding bytes, without operator += and T::iterator_category = std::forward_iterator_tag</h2>
<p>This section applies for iterators where std::iterator_traits&lt;T&gt;::iterator_category is exactly or convertible to std::forward_iterator_tag. In this case, two calls to "*iter" will never occur in direct succession, but multiple calls to "++iter" might directly follow each other to skip over padding bytes:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;*iter = x;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;++iter;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;*iter = x;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;++iter;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;++iter;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;*iter = x;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;++iter;</div></div><!-- fragment --><h2><a class="anchor" id="ConIter7"></a>
Output Iterator with padding bytes, with operator += and T::iterator_category = std::forward_iterator_tag</h2>
<p>This section applies for iterators where std::iterator_traits&lt;T&gt;::iterator_category is exactly or convertible to std::forward_iterator_tag. With "n" being an instance of std::iterator_traits&lt;T&gt;::difference_type, "iter += n" should skip over n bytes. Two calls to "(*iter)=x" will never occur in direct succession, "++iter" will always follow "(*iter)=x", "iter += n" can optionally follow a "++iter", and "(*iter)=x" will follow either "++iter" or "iter += n", e.g.:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;*iter = x;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;++iter;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;*iter = x;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;++iter;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;iter += 2;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;*iter = x;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;++iter;</div></div><!-- fragment --><h1><a class="anchor" id="ConDyn"></a>
Dynamic data structures</h1>
<p>Data structures are considered dynamic if their size is not known at compile time, but is determined at runtime based on data available only then. For deserialization, the size of a dynamic data structure might depend on other data objects that have just been deserialized. The serialized size of any dynamic data structure must be equal to or a multiple of the size of a serialization word. This restriction ensures that data that comes after the dynamic data always starts at the same bit in one serialization word, which greatly improves performance. For example, if you want to serialize a std::vector&lt;std::uint16_t&gt;, the serialization word can only be std::uint8_t or std::uint16_t, but not std::uint32_t. Since dynamic data structures always have the potential to overflow the raw buffer, error handling is required unless <a class="el" href="structuSer_1_1InfSize.html">InfSize</a> is specified as the buffer size.</p>
<p>µSer supports three different kinds of dynamic data:</p>
<h2><a class="anchor" id="ConDyn1"></a>
Containers with dynamic size</h2>
<p>When serializing a container that is not std::array or a C-Array, µSer will assume it to be dynamic, and query its size by using its ".size()" member function. µSer will serialize or deserialize exactly as many elements. This means that the prior to deserialization, the container needs to be set to its desired size, as µSer will never resize containers.</p>
<p>We have already seen how to serialize std::vector: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::uint16_t&gt; x { 0x4554, 0x5453 };</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual serialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">        <span class="comment">// Write the binary data to standard output.</span></div><div class="line">        std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Deserialization then works like this: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array with the raw binary data.</span></div><div class="line">    <span class="keyword">const</span> std::uint8_t raw [4] { 0x54, 0x45, 0x53, 0x54 };</div><div class="line">    <span class="comment">// Define a vector to receive the deserialized data and allocate it to the desired size.</span></div><div class="line">    std::vector&lt;std::uint16_t&gt; x (2);</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual deserialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line">        <span class="comment">// Write the data to standard output.</span></div><div class="line">        std::cout &lt;&lt; std::hex &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; x [0] &lt;&lt; <span class="stringliteral">&quot;, 0x&quot;</span> &lt;&lt; x [1] &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Note how the vector is initialized to have 2 elements. Passing a greater integer will cause an exception as the buffer would overflow.</p>
<h2><a class="anchor" id="ConDyn2"></a>
Dynamic size of struct members via Dyn::Size</h2>
<p>By annotating a container member of a <a class="el" href="tutorial.html#ConStructAnnot">struct</a> with the <a class="el" href="structuSer_1_1Dyn_1_1Size.html">Dyn::Size</a> attribute, you can make its size depend on various kinds of runtime data. The sole argument to Dyn::Size is a reference which tells µSer what size the container has. The reference can be:</p><ol type="1">
<li>A non-static member function of the surrounding struct</li>
<li>A free function (=function pointer)</li>
<li>A static member function of any class (=function pointer)</li>
<li>A pointer to a global object that has operator () overloaded</li>
<li>A member variable pointer to a member of the surrounding struct, which must be convertible to std::size_t. In the first four cases, the return type must be convertible to std::size_t. For cases 2-4, a reference to the struct is passed as an argument.</li>
</ol>
<p>This example shows four variants:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>A;</div><div class="line">std::size_t g_getSize (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp;);</div><div class="line"></div><div class="line"><span class="comment">// Functional for determining the dynamic size (class with operator () overloaded)</span></div><div class="line"><span class="keyword">struct </span>Functional {</div><div class="line">    std::size_t operator () (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp;);</div><div class="line">} functional;</div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Member function for determining the dynamic size</span></div><div class="line">    std::size_t m_getSize ()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> N2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Size of array1</span></div><div class="line">    std::uint16_t N1;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array</span></div><div class="line">    std::uint8_t array1 [20];</div><div class="line">    <span class="comment">// Define the array size dynamically using a member variable</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (array1, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;A::N1&gt;)</div><div class="line"></div><div class="line">    std::uint16_t N2;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array</span></div><div class="line">    std::uint8_t array2 [20];</div><div class="line">    <span class="comment">// Define the array size dynamically using a member function</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (array2, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;A::m_getSize&gt;)</div><div class="line"></div><div class="line">    std::uint16_t N3;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array</span></div><div class="line">    std::uint8_t array3 [20];</div><div class="line">    <span class="comment">// Define the array size dynamically using a free function</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (array3, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;g_getSize&gt;)</div><div class="line"></div><div class="line">    std::uint16_t N4;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array</span></div><div class="line">    std::uint8_t array4 [20];</div><div class="line">    <span class="comment">// Define the array size dynamically using a functional (class with operator () overloaded)</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (array4, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;functional&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (N1, array1, N2, array2, N3, array3, N4, array4)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Free function for determining the dynamic size</span></div><div class="line">std::<span class="keywordtype">size_t</span> g_getSize (const struct A&amp; a) {</div><div class="line">    <span class="keywordflow">return</span> a.N3;</div><div class="line">}</div><div class="line"></div><div class="line">std::size_t Functional::operator () (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp; a) {</div><div class="line">    <span class="keywordflow">return</span> a.N4;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array with binary data</span></div><div class="line">    <span class="keyword">const</span> std::uint8_t raw [26] = { 0x03, 0x00, 0x01, 0x02, 0x03,</div><div class="line">                                        0x04, 0x00, 0x01, 0x02, 0x03, 0x04,</div><div class="line">                                        0x05, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,</div><div class="line">                                        0x06, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };</div><div class="line">    <span class="comment">// Define a struct to receive the deserialized data</span></div><div class="line">    A x;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual deserialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line"></div><div class="line">        <span class="comment">// Write the read data to standard output.</span></div><div class="line"></div><div class="line">        std::copy (x.array1, x.array1 + x.N1, std::ostream_iterator&lt;int&gt; (std::cout, <span class="stringliteral">&quot;, &quot;</span>)); std::cout &lt;&lt; std::endl;</div><div class="line">        std::copy (x.array2, x.array2 + x.N2, std::ostream_iterator&lt;int&gt; (std::cout, <span class="stringliteral">&quot;, &quot;</span>)); std::cout &lt;&lt; std::endl;</div><div class="line">        std::copy (x.array3, x.array3 + x.N3, std::ostream_iterator&lt;int&gt; (std::cout, <span class="stringliteral">&quot;, &quot;</span>)); std::cout &lt;&lt; std::endl;</div><div class="line">        std::copy (x.array4, x.array4 + x.N4, std::ostream_iterator&lt;int&gt; (std::cout, <span class="stringliteral">&quot;, &quot;</span>)); std::cout &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ConDyn3"></a>
Optional struct members via Dyn::Optional</h2>
<p>By annotating a container member of a <a class="el" href="tutorial.html#ConStructAnnot">struct</a> with the <a class="el" href="structuSer_1_1Dyn_1_1Optional.html">Dyn::Optional</a> attribute, you can make its presence depend on various kinds of runtime data. The sole argument to Dyn::Optional is a reference which tells µSer whether the object exists. For the reference, the same rules as for Size apply, but the return type has to be (convertible) to bool.</p>
<p>This example shows four variants:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>A;</div><div class="line"><span class="keywordtype">bool</span> g_getSize (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp;);</div><div class="line"></div><div class="line"><span class="comment">// Functional for determining the existence (class with operator () overloaded)</span></div><div class="line"><span class="keyword">struct </span>Functional {</div><div class="line">    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp;);</div><div class="line">} functional;</div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Member function for determining whether an object is present</span></div><div class="line">        <span class="keywordtype">bool</span> m_getSize ()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> N2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Begin declaration</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    <span class="comment">// 1 if v1 exists, 0 else</span></div><div class="line">    std::uint8_t N1;</div><div class="line"></div><div class="line">    <span class="comment">// Define an optional object</span></div><div class="line">    std::uint8_t v1;</div><div class="line">    <span class="comment">// Define the presence of an object to be optional using a member variable</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (v1, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Optional&lt;&amp;A::N1&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// 1 if v2 exists, 0 else</span></div><div class="line">    std::uint8_t N2;</div><div class="line"></div><div class="line">    <span class="comment">// Define an optional object</span></div><div class="line">    std::uint8_t v2;</div><div class="line">    <span class="comment">// Define the presence of an object to be optional using a member function</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (v2, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Optional&lt;&amp;A::m_getSize&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// 1 if v3 exists, 0 else</span></div><div class="line">    std::uint8_t N3;</div><div class="line"></div><div class="line">    <span class="comment">// Define an optional object</span></div><div class="line">    std::uint8_t v3;</div><div class="line">    <span class="comment">// Define the presence of an object to be optional using a free function</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (v3, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Optional&lt;&amp;g_getSize&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// 1 if v4 exists, 0 else</span></div><div class="line">    std::uint8_t N4;</div><div class="line"></div><div class="line">    <span class="comment">// Define an optional object</span></div><div class="line">    std::uint8_t v4;</div><div class="line">    <span class="comment">// Define the presence of an object to be optional using a functional (class with operator () overloaded)</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (v4, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Optional&lt;&amp;functional&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (N1, v1, N2, v2, N3, v3, N4, v4)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Free function for determining the presence</span></div><div class="line"><span class="keywordtype">bool</span> g_getSize (const struct A&amp; a) {</div><div class="line">    <span class="keywordflow">return</span> a.N3 != 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> Functional::operator () (<span class="keyword">const</span> <span class="keyword">struct</span> A&amp; a) {</div><div class="line">    <span class="keywordflow">return</span> a.N4 != 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array with binary data</span></div><div class="line">    <span class="keyword">const</span> std::uint8_t raw [6] = {  0x01, 0x01,</div><div class="line">                                    0x00,</div><div class="line">                                    0x01, 0x2A,</div><div class="line">                                    0x00 };</div><div class="line">    <span class="comment">// Define a struct to receive the deserialized data</span></div><div class="line">    A x;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Perform the actual deserialization.</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line"></div><div class="line">        <span class="comment">// Write the read data to standard output.</span></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (x.N1) std::cout &lt;&lt; <span class="stringliteral">&quot;v1: &quot;</span> &lt;&lt; std::hex &lt;&lt; int (x.v1) &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (x.N2) std::cout &lt;&lt; <span class="stringliteral">&quot;v2: &quot;</span> &lt;&lt; std::hex &lt;&lt; int (x.v2) &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (x.N3) std::cout &lt;&lt; <span class="stringliteral">&quot;v3: &quot;</span> &lt;&lt; std::hex &lt;&lt; int (x.v3) &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (x.N4) std::cout &lt;&lt; <span class="stringliteral">&quot;v4: &quot;</span> &lt;&lt; std::hex &lt;&lt; int (x.v4) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The variables N1-N4 are declared as std::uint8_t to avoid odd data in the example.</p>
<h1><a class="anchor" id="ConHooks"></a>
Hooks</h1>
<p>Sometimes it is necessary to do some application-specific calculations and checks during (de)serialization. µSer accommodates this by allowing the application to specify hook functions which will be called before or after an object is (de)serialized. This can be achieved by the four attributes <a class="el" href="structuSer_1_1Hook_1_1SerPre.html">Hook::SerPre</a>, <a class="el" href="structuSer_1_1Hook_1_1SerPost.html">Hook::SerPost</a>, <a class="el" href="structuSer_1_1Hook_1_1DeSerPre.html">Hook::DeSerPre</a>, <a class="el" href="structuSer_1_1Hook_1_1DeSerPost.html">Hook::DeSerPost</a>. These attributes take a reference to a function which will be called before/after the annotated object is (de)serialized. The argument may reference:</p><ol type="1">
<li>A non-static constant (for serialization) or non-constant (for deserialization) member function of the surrounding struct</li>
<li>A free function (=function pointer)</li>
<li>A static member function of any class (=function pointer)</li>
<li>A pointer to a global object that has operator () overloaded</li>
<li>If the annotated object is a struct, and the annotation is <em>not</em> given as a member annotation of a surrounding struct, the reference may be a non-static constant (for serialization) or non-constant (for deserialization) member function of that struct.</li>
</ol>
<p>The return type can be:</p><ol type="1">
<li>void, in which case the function may indicate errors via exceptions, but not fail otherwise</li>
<li><a class="el" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a>, in which case the function may indicate errors by the returned value or via exceptions (if enabled). If the function indicates an error via a return value and exceptions are enabled, µSer will throw an exception that forwards the error code.</li>
</ol>
<p>A constant (for serialization) or non-constant (for deserialization) reference to the annotated object is passed as the first argument. For cases 2-4, a constant (for serialization) or non-constant (for deserialization) reference to the struct is passed as a second argument, if the attribute was applied to a struct member.</p>
<p>An example for the different reference types and hook types is: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#define USER_EXCEPTIONS</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>A;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> serPost (<span class="keyword">const</span> uint8_t&amp;, <span class="keyword">const</span> A&amp;);</div><div class="line"></div><div class="line"><span class="comment">// Functional to be called before deserialization</span></div><div class="line"><span class="keyword">struct </span>DeSerPre {</div><div class="line">    <span class="keywordtype">void</span> operator () (uint8_t&amp;, A&amp;);</div><div class="line">} deSerPre;</div><div class="line"></div><div class="line"><span class="comment">// Define a serializable struct</span></div><div class="line"><span class="keyword">struct </span>A {</div><div class="line">    <span class="comment">// Member function to be called before serialization</span></div><div class="line">    <span class="keywordtype">void</span> serPre (<span class="keyword">const</span> uint8_t&amp; a)<span class="keyword"> const </span>{</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;SerPre\n&quot;</span>;</div><div class="line">        <span class="comment">// Simulate an error condition</span></div><div class="line">        <span class="keywordflow">if</span> (a != 42)</div><div class="line">            <span class="keywordflow">throw</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a> (<a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2abadcb3f06ddb8821cd593f31234c23733b">uSer_EHOOK</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Member function to be called after deserialization</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> deSerPost () {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DeSerPost\n&quot;</span>;</div><div class="line">        <span class="comment">// Simulate an error condition</span></div><div class="line">        <span class="keywordflow">return</span> a == 42 ? <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a> : <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2abadcb3f06ddb8821cd593f31234c23733b">uSer_EHOOK</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Begin declaration. Define hook to be called after deserialization of the whole struct.</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (A, <a class="code" href="structuSer_1_1Hook_1_1DeSerPost.html">uSer::Hook::DeSerPost&lt;&amp;A::deSerPost&gt;</a>)</div><div class="line"></div><div class="line">    <span class="comment">// Define some members</span></div><div class="line">    std::uint8_t a, b, c;</div><div class="line"></div><div class="line">    <span class="comment">// Define hooks to be called before/after (de)serialization of the individual members</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(a, <a class="code" href="namespaceuSer.html">uSer</a>::Hook::SerPre&lt;&amp;A::serPre&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(b, <a class="code" href="namespaceuSer.html">uSer</a>::Hook::SerPost&lt;&amp;serPost&gt;)</div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(c, <a class="code" href="namespaceuSer.html">uSer</a>::Hook::DeSerPre&lt;&amp;deSerPre&gt;)</div><div class="line"></div><div class="line">    <span class="comment">// Make members known to µSer</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Hook function to be called after serialization</span></div><div class="line"><span class="keywordtype">void</span> serPost (const uint8_t&amp;, const A&amp;) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;SerPost\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> DeSerPre::operator () (uint8_t&amp;, A&amp;) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DeSerPre\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [3];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    A x { 42, 2, 3 };</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Serialize &amp; deserialize</span></div><div class="line">        <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">        <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classuSer_1_1Exception.html">uSer::Exception</a>&amp; ex) {</div><div class="line">        <span class="comment">// In case of error, print it</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;uSer Error: &quot;</span> &lt;&lt; ex.what () &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Note that during the pre-deserialization hook, the object might not contain any meaningful data.</p>
<h1><a class="anchor" id="ConBufSize"></a>
Calculating buffer sizes</h1>
<p>µSer allows you to determine the size of the raw buffer based on the C++ data structure during compilation. This can be useful to allocate buffers of appropriate size.</p><ul>
<li>rawStaticBits&lt;RawIter, T, Attr...&gt; returns the number of fixed bits belonging to the non-dynamic part of T in the raw data stream referred to by the raw iterator type RawIter when serializing with the attributes Attr.</li>
<li><a class="el" href="namespaceuSer.html#af48a7b87d63958c678e25e80bb777cdd">RawMaxDynamic&lt;RawIter, T, Attr...&gt;</a> is an alias to either <a class="el" href="structuSer_1_1MaxSize.html">MaxSize</a>, <a class="el" href="structuSer_1_1Unlimited.html">Unlimited</a> or <a class="el" href="structuSer_1_1NoDyn.html">NoDyn</a> indicating the upper limit of dynamic serialization words in its member value, that there is no upper limit, or that there is no dynamic data, respectively.</li>
<li>minBufSize&lt;RawIter, T, Attr...&gt; is an integer denoting the minimum number of serialization words needed to (de)serialize the type T.</li>
<li>maxBufSize&lt;RawIter, T, Attr...&gt; is an integer denoting the maximum number of serialization words needed to (de)serialize the type T. Using this alias may cause a compiler error if the dynamic size is unlimited. Note that the maximum size might actually never occur depending on the data structure.</li>
</ul>
<h1><a class="anchor" id="Minimize"></a>
Using µSer on resource-constrained systems</h1>
<p>µSer is designed to work on resource-constrained systems, such as small embedded systems. To this end, µSer never does any dynamic memory allocation. There are also some macros that can be defined <em>before</em> including the <a class="el" href="uSer_8hh.html" title="Main header file for the µSer Serialization library. ">uSer.hh</a> header (or via the compiler's command line) to configure µSer:</p><ul>
<li><a class="el" href="optional_8cpp.html#ac62717affc27361b1479a8beeb13abfc">USER_EXCEPTIONS</a> Do <em>not</em> define this macro in order to disable exception support, which typically consumes a large amount of program memory</li>
<li><a class="el" href="optional_8cpp.html#a084bef85c79e8fbaa5faf7553c312cf6">USER_NO_PRINT</a> Define this macro to disable support for printing serializable data via the <a class="el" href="namespaceuSer.html#aad93ce8faec41b3dc4e3cf76501015b1">uSer::print</a> function and prevent inclusion of the &lt;ostream&gt; header.</li>
<li><a class="el" href="optional_8cpp.html#ad7d692d9b17881dab6d89593d413f8ad">USER_NO_SMARTPTR</a> Define this macro to disable support for smart pointers and prevent inclusion of the &lt;memory&gt; header.</li>
</ul>
<p>When using GCC, compile with "-fdata-sections -ffunction-sections -flto", and link with "-Wl,--gc-sections -flto". These options can reduce the amount of program memory needed. µSer also relies on optimization to be turned on (e.g. -O2 for GCC and Clang) to generate efficient code. µSer employs deeply nested call stacks to statically build algorithms specifically adapted to the user-defined data structures. With optimization enabled, the compiler collapses those into short and efficient algorithms. If some code does not work with optimizations enabled, this is most probably the result of relying on some undefined behaviour, i.e. programming errors. Using µSer instead of e.g. pointer casts to serialize data already avoids some of those problems (specifically padding, data alignment, aliasing rules).</p>
<h1><a class="anchor" id="CCompat"></a>
C-Compatibility</h1>
<p>µSer can be used in C-based projects if a C++17-compatible compiler is available. Fist, define the desired data structures in a common header for both C and C++ (here: packet.h): </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define data structures compatible with both C and C++.</span></div><div class="line"></div><div class="line"><span class="comment">// Define a simple struct containing integers</span></div><div class="line"><span class="keyword">struct </span>PacketA {</div><div class="line">    <span class="comment">// Begin struct definition</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a>(PacketA, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    uint32_t a;</div><div class="line">    <span class="comment">// Encode a in Big-Endian in the raw data</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(a, <a class="code" href="namespaceuSer.html">uSer</a>::ByteOrder::BE)</div><div class="line"></div><div class="line">    uint16_t b;</div><div class="line">    int8_t c;</div><div class="line">    <span class="comment">// Encode c in signed-magnitude format in the raw data</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a>(c, <a class="code" href="namespaceuSer.html">uSer</a>::SignFormat::SignedMagnitude)</div><div class="line"></div><div class="line">    <span class="comment">// List members</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (a, b, c)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Define a struct containing a dynamic data structure. Use the &quot;typedef struct&quot;-Trick to make usage more convenient.</span></div><div class="line">typedef struct PacketB_ {</div><div class="line">    <span class="comment">// Begin struct definition</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a3c3db54164091093c62af605d97c113e">USER_STRUCT</a> (PacketB_, <a class="code" href="group__Attr.html#gaeab6739fe40911e5564792c498f0de01">uSer::AttrNone</a>)</div><div class="line"></div><div class="line">    uint8_t N;</div><div class="line">    struct PacketA packets [8];</div><div class="line">    <span class="comment">// Let N denote the size of the arra packets.</span></div><div class="line">    <a class="code" href="uSer_8hh.html#aa9fd5f0392d3b7830ad9443d4b168885">USER_MEM_ANNOT</a> (packets, <a class="code" href="namespaceuSer.html">uSer</a>::Dyn::Size&lt;&amp;PacketB_::N&gt;)</div><div class="line"></div><div class="line">    <a class="code" href="uSer_8hh.html#a0c959995dc9db6e1863ccd03e7715a3f">USER_ENUM_MEM</a> (N, packets)</div><div class="line">} PacketB;</div><div class="line"></div><div class="line"><span class="comment">// Declare functions for (de)serialization of the data structure. These will be implemented as C++.</span></div><div class="line"></div><div class="line"><a class="code" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> serializePacketB (uint8_t* raw, const PacketB* pk, <span class="keywordtype">size_t</span> bufferSize);</div><div class="line"><a class="code" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> deserializePacketB (const uint8_t* raw, PacketB* pk, <span class="keywordtype">size_t</span> bufferSize);</div></div><!-- fragment --><p> Define the structs by using the µSer-provided macros <a class="el" href="tutorial.html#ConStructAnnot">as explained before</a>. Also declare serialize/deserialize functions as needed, i.e. for the structs we want to explicitly serialize from C code. In this example, we only want to (de)serialize PacketB from C, and have the contained PacketA instances (de)serialized automatically. Therefore, we don't need serialization functions for PacketA. Adjust the signature as needed (with or without error codes in the return type, the desired raw buffer type, with or without a buffer size parameter). In order to call a C++ function from C, it has to be annotated with 'extern "C"', but only when the C++ compiler sees it. The <a class="el" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> macro can be used for this, which evaluates to 'extern "C"' when compiling as C++, and to nothing when compiling as C.</p>
<p>Then, create a C++ source file for implementing the serialization functions: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;packet.h&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> serializePacketB (uint8_t* raw, <span class="keyword">const</span> PacketB* pk, <span class="keywordtype">size_t</span> bufferSize) {</div><div class="line">    <span class="comment">// Just call the µSer serialization function</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, *pk, bufferSize);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="uSer_8hh.html#a81310d2a19e5bbc38a4db76bbcd41b81">USER_EXTERN_C</a> <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> deserializePacketB (<span class="keyword">const</span> uint8_t* raw, PacketB* pk, <span class="keywordtype">size_t</span> bufferSize) {</div><div class="line">    <span class="comment">// Just call the µSer deserialization function</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, *pk, bufferSize);</div><div class="line">}</div></div><!-- fragment --><p> We have to include the "packet.h" file, and just call <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">serialize</a>/<a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">deserialize</a> in the function body. Remember to switch on the compiler's C++17 support (e.g. -std=c++17 for GCC and Clang). We can then use these functions from C code, e.g.: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;inttypes.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;packet.h&quot;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define a packet instance and fill it with some data</span></div><div class="line">    PacketB pk;</div><div class="line">    pk.N = 2;</div><div class="line">    pk.packets [0].a = 0xDEADBEEF;</div><div class="line">    pk.packets [0].b = 0xAA55;</div><div class="line">    pk.packets [0].c = -42;</div><div class="line"></div><div class="line">    pk.packets [1].a = 0xC0FEBABE;</div><div class="line">    pk.packets [1].b = 0x1234;</div><div class="line">    pk.packets [1].c = 35;</div><div class="line"></div><div class="line">    <span class="comment">// Define an array to receive the raw data</span></div><div class="line">    uint8_t raw [15];</div><div class="line">    <span class="comment">// Serialize the packet into the raw data</span></div><div class="line">    <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2ab">uSer_ErrorCode</a> ec = serializePacketB (raw, &amp;pk, <span class="keyword">sizeof</span> (raw) <span class="comment">/* uint8_t always has size 1 */</span>);</div><div class="line">    <span class="comment">// Check for errors</span></div><div class="line">    <span class="keywordflow">if</span> (ec != <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a>) {</div><div class="line">        fprintf (stderr, <span class="stringliteral">&quot;Serialization error: %s\n&quot;</span>, <a class="code" href="uSer_8hh.html#ae554bbbb88b9dd386e21dda79645dca1">uSer_getErrorMessage</a> (ec));</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// Print the raw data</span></div><div class="line">        puts (<span class="stringliteral">&quot;Serialization result:&quot;</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <span class="keyword">sizeof</span>(raw); ++i) {</div><div class="line">            printf (<span class="stringliteral">&quot;%02x, &quot;</span>, raw [i]);</div><div class="line">        }</div><div class="line">        puts (<span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Deserialize the raw data back into the struct</span></div><div class="line">    ec = deserializePacketB (raw, &amp;pk, <span class="keyword">sizeof</span> (raw));</div><div class="line">    <span class="comment">// Check for errors</span></div><div class="line">    <span class="keywordflow">if</span> (ec != <a class="code" href="uSer_8hh.html#a8c7fd658da9e8986d7c7895b1e41c2aba6cdbcce712ac5d9be458f121d0b2c557">uSer_EOK</a>) {</div><div class="line">        fprintf (stderr, <span class="stringliteral">&quot;Deserialization error: %s\n&quot;</span>, <a class="code" href="uSer_8hh.html#ae554bbbb88b9dd386e21dda79645dca1">uSer_getErrorMessage</a> (ec));</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// Print the deserialized data structure</span></div><div class="line">        puts (<span class="stringliteral">&quot;Deserialization result:&quot;</span>);</div><div class="line"></div><div class="line">        printf (<span class="stringliteral">&quot;pk.N=%&quot;</span> PRIu8 <span class="stringliteral">&quot;\n&quot;</span>, pk.N);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; pk.N; ++i) {</div><div class="line">            printf (<span class="stringliteral">&quot;pk.packets[%zd].a=%&quot;</span> PRIx32 <span class="stringliteral">&quot;, .b=%&quot;</span> PRIx16 <span class="stringliteral">&quot;, .c=%&quot;</span> PRId8 <span class="stringliteral">&quot;\n&quot;</span>, i, pk.packets [i].a, pk.packets [i].b, pk.packets [i].c);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">µSer Serialization Library</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
