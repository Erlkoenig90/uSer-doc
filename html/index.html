<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>µSer: µSer Serialization Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">µSer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">µSer Serialization Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>This is the documentation for the µSer portable serialization library for C++17. Serialization is the process of turning data represented in data types of a programming language into a "flat" representation - typically, a sequence of bytes (8-Bit Integers - strictly, "Octets"). Deserialization is the opposite direction - bytes to data structures. This is necessary for transmitting data over a network or storing it into files. In other words, serialization is the answer to the question "How to convert an uint32_t to an uint8_t[4], and vice versa?".</p>
<p>There are many approaches and libraries to achieve this goal. Most of them focus on quickly and easily storing arbitrary data in a convenient format, such as XML, JSON or some specific binary representation. In contrast to that, µSer's main goal is to support given arbitrary binary formats in a platform-independent manner. Ideally, it should be possible to take a given binary format (e.g. defined by a standardized communication protocol or file format), write code based on µSer to handle the format once, and run it on any platform without modification, special compiler flags or language extensions. Basically, µSer provides a portable function to turn any data type into a uint8_t[] and back.</p>
<p>The key features are:</p><ul>
<li>µSer is implemented as a header-only metaprogramming library for C++17.</li>
<li>No external tools, code generators, or specification languages are needed; everything is done by the C++ compiler.</li>
<li>µSer is easy to integrate into existing codebases; ideally, the serialization functions serve as drop-in replacements for memcpy.</li>
<li>The annotated structs are <a class="el" href="tutorial.html#CCompat">compatible with C</a>, if no other C++ features are used. This makes it possible to define your data structures by a tree of structs in a header file that is shared between C and C++ code. Effectively, only very few lines of C++ codes are necessary to call µSer's functions. This makes it easy to integrate µSer into C projects.</li>
<li>For the raw data, µSer supports the byte orders <a class="el" href="structuSer_1_1ByteOrder_1_1LE.html">little endian</a>, <a class="el" href="structuSer_1_1ByteOrder_1_1BE.html">big endian</a> and <a class="el" href="structuSer_1_1ByteOrder_1_1PDP.html">PDP endian</a>. The byte order of the platform the application is running on has no influence on µSer's workings - in theory, µSer would continue to work on platforms with even different orders. The compiler's implementation of bitshifts should make sure that the bits end up in the right place.</li>
<li>Signed integers can be represented in the raw data using <a class="el" href="structuSer_1_1SignFormat_1_1TwosComplement.html">Two's complement</a>, <a class="el" href="structuSer_1_1SignFormat_1_1OnesComplement.html">One's complement</a> and <a class="el" href="structuSer_1_1SignFormat_1_1SignedMagnitude.html">Signed-Magnitude</a>. Again, the format of the host platform is irrelevant for µSer.</li>
<li>µSer accepts data in the following types, known as serializable types:<ul>
<li>All signed and unsigned integers</li>
<li>Classes containing serializable member variables, if annotated correctly</li>
<li>C-Arrays and std::array of serializable types</li>
<li>Containers that support iterators, including those of the C++ Standard Library</li>
<li>std::tuple's and std::pair's of serializable types</li>
</ul>
</li>
<li>The size of the binary representation of any object need not be a multiple of the byte size. µSer simulates bitfields in the binary data without actually using the C++-provided bitfields. This e.g. allows you to serialize one 11-Bit-Integer and 7 3-Bit-Integers into 3 Bytes ( = 32 bits).</li>
<li>µSer makes no assumptions about the platform implementation especially regarding sizes of integer types, number of bits in a char (CHAR_BIT), sign formats, byte order, padding bytes, alignment requirements, overflow behaviour and aliasing, except as guaranteed by the C++17 standard. This allows you to use the same code on any platform and get the same result, or a compiler error if this is not possible (rather than random runtime failures).</li>
<li>µSer achieves the desired data conversions by careful application of bitwise operations (mainly shifts and bitwise or). This avoids any reliance on implementation-defined behaviour and allows µSer to work consistently regardless of the presence of certain compiler options (especially regarding optimization, strict aliasing, or integer types), compiler version, processor architecture, or operating system.</li>
<li>µSer is actually not limited to 8-bit-Bytes for the raw binary data - any unsigned integer type can be used to store the raw data. This underlying unsigned integer type will be called "serialization word", or short "SWord". This simplifies transmitting data over interfaces which accept e.g. 16 bits at once.</li>
<li>The raw data can be stored in C-Arrays, std::array, or any other homogeneous container made up serialization words. It is also possible to provide arbitrary iterators for raw data input/output. This makes it possible to transmit/receive the raw data directly to/from any communication interface SWord by SWord.</li>
<li>µSer has limited support for dynamic data structures, i.e. structures whose size is only known at runtime. The sizes of arrays can depend on previously (de)serialized data, as long as the size of the contained element is a multiple of the size of an SWord. Individual objects can be serialized or not depending on previous data as well, if their size is a multiple of the SWord size.</li>
<li>µSer does not use dynamic memory management, and support for exceptions is optional. Whenever µSer uses a bit-shifting operator, the right-hand argument of "&gt;&gt;" or "&lt;&lt;" is always a compile-time known constant, making the bitshifts efficient even if the processor does not feature a barrel shifter. This makes it possible to use µSer on small embedded systems, hence its name.</li>
<li>As an auxiliary functionality for testing purposes, µSer can <a class="el" href="namespaceuSer.html#aad93ce8faec41b3dc4e3cf76501015b1">print</a> and <a class="el" href="namespaceuSer.html#a0bcb554ad11e561747e963849af6a376">compare</a> serializable types.</li>
<li>µSer is available under an open source license that also allows commercial usage, see below.</li>
</ul>
<p>Limitations:</p><ul>
<li>There is currently no support for floating-point numbers.</li>
<li>C++17 support is not widespread yet. As of this writing, only Clang and GCC support enough of C++17 to compile µSer. Since C++17 greatly simplifies metaprogramming and other compilers can be expected to catch up, older language standards are not supported by µSer.</li>
<li>Not every conceivable format can be serialized by µSer.</li>
<li>Compiling template-heavy code is slow; translating a code base with ~2000 individual calls to the serialization functions takes 7 minutes on an i3-4010U CPU. This can be worked around by placing the calls to the serialization functions in individual files that can be compiled in parallel and only need to be recompiled if the format changes.</li>
<li>µSer makes no effort in resolving circles and redundant paths in object graphs - i.e. if some objects reference each other, µSer will enter an endless loop. If the same object is referenced twice, it will be serialized twice.</li>
<li>Compilation errors related to metaprogramming are often hard to read. Where possible, µSer prints readable error messages via static_assert when an unsupported combination of data types and attributes was requested.</li>
<li>Using the declaration macros, structs can have at maximum 364 members. If more are needed, they have to be annotated manually.</li>
</ul>
<h1><a class="anchor" id="License"></a>
License</h1>
<p>Copyright (C) 2018 Niklas Gürtler<br />
 Contains a modified version of the <a href="https://github.com/swansontec/map-macro">Map-Macro</a> Copyright (C) 2012 William Swanson<br />
 <br />
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<p>Except as contained in this notice, the names of the authors or their institutions shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the authors.</p>
<h1><a class="anchor" id="GettingStarted"></a>
Getting started</h1>
<p>To start using µSer, download the project's source code, add the contained "uSer" directory to the compiler's include path, or just copy the <a class="el" href="uSer_8hh.html">uSer/uSer.hh</a> file into your project. Switch on your compiler's C++17 support, e.g. by passing "-std=c++17" to the command line for GCC and Clang. Add an include directive to your C++ source code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div></div><!-- fragment --><p> Now you can start serializing data! A basic example is: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array to receive the raw binary data.</span></div><div class="line">    std::uint8_t raw [4];</div><div class="line">    <span class="comment">// Define the data to be serialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint32_t x = 0x54534554;</div><div class="line">    <span class="comment">// Perform the actual serialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the binary data to standard output.</span></div><div class="line">    std::cout.write (reinterpret_cast&lt;char*&gt; (raw), 4) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> After defining a buffer for the raw data, and the data to be serialized, the <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">uSer::serialize</a> serialize function is called to do the conversion. After that, the uint8_t array contains the values 0x54, 0x45, 0x53, 0x54. This order does <em>not</em> depend on the byte order of the platform but is the <a class="el" href="structuSer_1_1ByteOrder_1_1LE.html">little endian</a> order, which is the default in µSer (can be changed). In other words, this result should be identical on all platforms, as long as they provide the types uint8_t and uint32_t. The four bytes are then written to the standard output. The four bytes just happen to be the ASCII encoding of the text "TEST", which is thereby output.</p>
<p>The opposite case of deserializing an array into an integer works as follows:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ios&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uSer_8hh.html">uSer.hh</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">    <span class="comment">// Define an array with binary data to be deserialized.</span></div><div class="line">    <span class="keyword">const</span> std::uint8_t raw [4] = { 0x54, 0x45, 0x53, 0x54 };</div><div class="line">    <span class="comment">// Define a variable that receives the deserialized data.</span></div><div class="line">    std::uint32_t x;</div><div class="line">    <span class="comment">// Perform the actual deserialization.</span></div><div class="line">    <a class="code" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">uSer::deserialize</a> (raw, x);</div><div class="line">    <span class="comment">// Write the result to standard output.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>See <a class="el" href="tutorial.html#CCompat">C-Compatibility</a> for how to use µSer in C projects.</p>
<h1><a class="anchor" id="Testcases"></a>
Testcases</h1>
<p>µSer ships with a set of unit tests. To run them, call "make" inside the "test" directory. If you only want to run the Clang tests, run "make run-clang". For g++, run "make run-gcc". Compiling the test cases takes a long time, but be careful with "-j" because it might eat up all your RAM. You will also probably need 64bit versions of the compiler's executable because it might consume more than 4 GB of RAM. Run "make run-gcc-quick" or "make run-clang-quick" to only perform a limited set of tests that compile much faster.</p>
<h1><a class="anchor" id="Documentation"></a>
Documentation</h1>
<ul>
<li><a class="el" href="tutorial.html">The In-Depth Tutorial</a> covers all concepts of µSer</li>
<li><a class="el" href="Examples.html">List of all examples</a></li>
<li><a class="el" href="group__Attr.html">List of attributes</a></li>
<li>Documentation for the <a class="el" href="namespaceuSer.html#a45c321581ed611cdce05225d0d7f4573">serialize</a> and <a class="el" href="namespaceuSer.html#a5d05bb728a8323898ee5b4cef5c1a3f8">deserialize</a> functions </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
